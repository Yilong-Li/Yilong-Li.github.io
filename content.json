{"meta":{"title":"Blog","subtitle":"MondayCha's","description":"","author":"DLee","url":"https://mondaycha.github.io","root":"/"},"posts":[{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab3 实验报告","date":"2020/04/24","text":"OS Lab3 实验报告一、实验思考题Thinking 3.1为什么我们在构造空闲进程链表时必须使用特定的插入的顺序？(顺序或者逆序) 答： 因为注释要求“确保在插入之后，env在列表中的顺序应该与envs数组中的相同”，这样就会使第一次调用env_alloc()时返回envs[0]。 Thinking 3.2思考env.c/mkenvid 函数和envid2env 函数: 请你谈谈对mkenvid 函数中生成id 的运算的理解，为什么这么做？ 为什么envid2env 中需要判断e->env_id != envid 的情况？如果没有这步判断会发生什么情况？ 答： (1) 生成ID的式子为return (++next_env_id < (1 + LOG2NENV)) | idx;env_id != envid验证从envs数组中获取的进程是否为所需进程。 Thinking 3.3结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数： 我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局) UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？ 在env_setup_vm 函数的最后，我们为什么要让pgdir[PDX(UVPT)]=env_cr3?(提示: 结合系统自映射机制) 谈谈自己对进程中物理地址和虚拟地址的理解 答： (1) 根据mmu.h里面的布局，我们的操作系统是2G/2G 模式，在本实验中，UTOP以上的虚拟地址空间到物理地址的映射关系都是一样的。因此复制内核的boot_pgdir中UTOP以上的内容到pgdir中，在进入内核态时不需要切换CR3寄存器。 (2) ULIM划分了用户空间与内核空间，UTOP属于用户空间，但UTOP至ULIM的区域与其他用户区相比，用户只能读不能写，其由三个4M大小的空间组成，分别存放进程envs数组、pages数组、进程页表。 (3) UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间为4MB ，这一区域就是进程的页表的位置，而PDX(UVPT)就是页目录自映射所对应的页目录在页表中的位置，因此要让pgdir[PDX(UVPT)]=env_cr3。 (4) 不同进程有各自的虚拟空间，访问相同虚拟地址时得到的结果可能是不同的；对于不同的进程而言，虚拟地址ULIM 以上的地方虚拟地址到物理地址的映射关系都是一样的，方便内核对进程进行管理。 Thinking 3.4思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子） 答： 不可以。在我们的实验中，与user_data有关的函数是load_icode、load_elf、load_icode_mapper，其中的user_data就是进程e的指针，是不可或缺的。 应用场景：load_icode_mapper是一个回调函数，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。C语言标准库中的排序qsort就用到了这种设计： void qsort(void*base,size_t num,size_t width,int(__cdecl*compare)(const void*,const void*)); 这之中的compare就是回调函数，两个形参是const void *型，有着很高的泛用性，与user_data的设计类似。 Thinking 3.5结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？ （提示：1、页面大小是多少；2、回顾lab1中的ELF文件解析，什么时候需要自动填充.bss段） 答： 若va不对齐，拷贝长度要选择BY2PG - offset和bin_size中的最小值，复制第一页。 i < bin_size时，如果i < bin_size - BY2PG，那么就以BY2PG步进，复制每一页；如果出现了BY2PG > bin_size - i的情况，那么依然要分配一页的空间。 如果i仍然小于sgsize，需要继续申请页面并置0。 .bss 段是全部要置零，也就包含在置零的空间中。 Thinking 3.6思考上面这一段话，并根据自己在lab2 中的理解，回答： 我们这里出现的” 指令位置” 的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？ 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？ 答： (1) 虚拟空间。当我们运行进程时，CPU 将自动从pc所指的位置开始执行二进制码，此时的空间是连续的，而虚拟空间对应的物理内存可能是不连续的，因此是虚拟空间。 (2) 一样。每个进程都有独立的虚拟空间，因此entry_point其值对于每个进程一样，是程序入口；但entry_point实际映射的物理地址不同。 Thinking 3.7思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？ 答： 要保存的进程上下文中的env_tf.pc的值应该设置为cp0_epc，从而从被中断的指令继续运行。 Thinking 3.8思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题： 请给出一个你认为合适的TIMESTACK 的定义 请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析) 思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同 答： (1) TIMESTACK以下[TIMESTACK - sizeof(struct Trapframe), TIMESTACK)的空间存储着异常发生时的寄存器信息，是时钟中断的存储区。 (2) 在include/stackframe.h中可以找到： .macro get_sp mfc0 k1, CP0_CAUSE andi k1, 0x107C xori k1, 0x1000 bnez k1, 1f nop li sp, 0x82000000 j 2f nop1: bltz sp, 2f nop lw sp, KERNEL_SP nop2: nop.endm 其中的0x82000000即TIMESTACK的值。本次实验产生的都是时钟中断（4号异常），进行的是li sp, 0x82000000的操作，因此是时钟中断的存储区。 (3) TIMESTACK是时钟中断的存储区，而KERNEL_SP应当是系统调用的存储区。 Thinking 3.9阅读 kclock_asm.S 文件并说出每行汇编代码的作用。 答： .macro setup_c0_status set clr // 定义宏setup_c0_status，传入set置位和clr清零形参 .set push // 保存现场 mfc0 t0, CP0_STATUS // 读CP0_STATUS的值到t0寄存器 or t0, \\set|\\clr // t0=(t0|set|clr)，将set为1的置1 xor t0, \\clr // t0= xor(t0,clr)，将clr为1的置0 mtc0 t0, CP0_STATUS // 将t0寄存器写回CP0_STATUS .set pop // 恢复现场.endm // 结束宏语句 .text // 代码段LEAF(set_timer) // LEAF定义不调用其他函数的叶子函数set_timer li t0, 0x01 // t0设为1 sb t0, 0xb5000100 // 设置实时钟中断的频率为1秒1次 sw sp, KERNEL_SP // 保存堆栈现场到KERNEL_SPsetup_c0_status STATUS_CU0|0x1001 0 // 设置CP0_STATUS，set为0x10001001 jr ra // 函数返回 nop // 延迟槽END(set_timer) // 结束函数 Thinking 3.10阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。 答： 首先在set_timer设置实时钟中断的频率，实验中为1秒1次。 一旦实时钟中断产生，就会触发MIPS 4号中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。 通过text.exc_vec3代码段的分发，调用handle_ int 函数来处理实时钟中断。 在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq。 在timer_ irq里跳转到sched_ yield，如果当前进程的时间片用完了，则切换到下一个进程。","permalink":"https://mondaycha.github.io/2020/04/24/424-2/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://mondaycha.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"424-1","date":"2020/04/24","text":"今天的内容是OS Lab3的学习复习笔记，然后下午去写理论课第八次作业。 在一开始同样放下优秀学长博客—— https://www.cnblogs.com/SivilTaram/p/oslab3.html https://ausar.xyz/index.php/archives/75/ Lab3的内容是进程与异常，将运行一个用户模式的进程。需要使用数据结构进程控制块 Env 来跟踪用户进程。通过建立一个简单的用户进程，加载一个程序镜像到进程控制块中，并让它运行起来。 进程控制块进程控制块(PCB) 是系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。 Exercise 3.2需要补充env_init 函数。 /*** exercise 3.2 ***/void env_init(void){ int i; /*Step 1: Initial env_free_list. */ LIST_INIT(&env_free_list); // 初始化env_free_list LIST_INIT(&env_sched_list[0]); LIST_INIT(&env_sched_list[1]); // 根据调度方法进行初始化，我把这步放在了env_init(void)函数里 /*Step 2: Traverse the elements of 'envs' array, * set their status as free and insert them into the env_free_list. * Choose the correct loop order to finish the insertion. * Make sure, after the insertion, the order of envs in the list * should be the same as it in the envs array. */ for (i = NENV - 1; i >= 0; i--) // 倒序插入，总共是1024个进程 { envs[i].env_status = ENV_FREE; /* 初始化进程状态 * 有ENV_FREE，ENV_NOT_RUNNABLE，ENV_RUNNABLE三种 * ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。 * ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态 * 处于该状态的进程往往在等待一定的条件才可以变为就绪状态从而被CPU 调度。 * ENV_RUNNABLE : 表明该进程处于就绪状态，正在等待被调度 * 但处于RUNNABLE 状态的进程可以是正在运行的，也可能不在运行中 */ LIST_INSERT_HEAD(&env_free_list, &envs[i], env_link); }} LIST_INSERT_HEAD效率高，采用逆序插入，确保在插入之后，env在列表中的顺序应该与envs数组中的相同，这样就会使第一次调用env_alloc()时返回envs[0]。 复习一下LIST_INSERT_HEAD，传入的三个参数分别为链表头、插入元素、链表指针。 #define LIST_INSERT_HEAD(head, elm, field) do { \\ if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) \\ LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\\ LIST_FIRST((head)) = (elm); \\ (elm)->field.le_prev = &LIST_FIRST((head)); \\ } while (0) 在Lab3要区分清楚env_link和env_sched_link。 Thinking 3.1为什么我们在构造空闲进程链表时必须使用特定的插入的顺序？(顺序或者逆序) 答： 因为注释要求“确保在插入之后，env在列表中的顺序应该与envs数组中的相同”，这样就会使第一次调用env_alloc()时返回envs[0]。 进程的标识每个进程都有独一无二的标识符，在创建每个新的进程的时候必须为它赋予一个与众不同的id来作为它的标识符，mkenvid的作用就是生成一个新的进程id。 u_int mkenvid(struct Env *e){ static u_long next_env_id = 0; /*Hint: lower bits of envid hold e's position in the envs array. */ u_int idx = e - envs; /*Hint: high bits of envid hold an increasing number. */ return (++next_env_id < (> 11) +----------------------------+------------0x8000 0000------- o | User VPT | PDMAP /|\\ o UVPT -----> +----------------------------+------------0x7fc0 0000 | o | PAGES | PDMAP | o UPAGES -----> +----------------------------+------------0x7f80 0000 | o | ENVS | PDMAP | o UTOP,UENVS -----> +----------------------------+------------0x7f40 0000 | o UXSTACKTOP -/ | user exception stack | BY2PG |*/ UTOP同样也是UENVS，而在3.1的mips_vm_init()，我们有这样一条操作： /* Step 3, Allocate proper size of physical memory for global array `envs`, * for process management. Then map the physical address to `UENVS`. */envs = (struct Env *)alloc(NENV * sizeof(struct Env), BY2PG, 1);n = ROUND(NENV * sizeof(struct Env), BY2PG);boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R); 在这里创建一个struct Env数组，大小为NENV个元素，而这也是全局的进程数组。通过boot_map_segment将envs对应的物理地址映射到虚拟地址UENVS，也就是说，这一块区域存储着所有的进程（mmu图中的ENVS）。 引用SivilTaram学长的解释—— 其实足以看出来，内核在映射的时候已经为用户留下了一条路径！一条获取其他进程信息的路途！而且我们其实可以知道，这一部分对于进程而言应当是只能读不可以写的。开启中断后我们在进程中再访问内核就会产生异常来陷入内核了，所以应该是为了方便读一些进程信息，内核专门开辟了这4M的用户进程虚拟区。用户读这4M空间的内容是不需要产生异常的。 嗯……果然我还是不大懂，然后就跟着注释把[0，UTOP)的进程页目录清零。 /*Step 2: Zero pgdir's field before UTOP. */for (i = 0; i < PDX(UTOP); i++){ pgdir[i] = 0;} 拷贝内核虚拟页目录的[UTOP,0xffffffff)区间的内容到进程页目录。 /*Step 3: Copy kernel's boot_pgdir to pgdir. */for (i = PDX(UTOP); i < PDX(0xffffffff); i++){ pgdir[i] = boot_pgdir[i];} 之后将pgdir保存在e->pgdir，将pgdir的物理地址保存到e->env_cr3中，并将其映射到进程页表中—— // UVPT maps the env's own page table, with read-only permission.e->env_pgdir[PDX(UVPT)] = e->env_cr3 | PTE_V; // read-only Thinking 3.3结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数： 我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局) UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？ 在env_setup_vm 函数的最后，我们为什么要让pgdir[PDX(UVPT)]=env_cr3?(提示: 结合系统自映射机制) 谈谈自己对进程中物理地址和虚拟地址的理解 答： (1) 根据mmu.h里面的布局，我们的操作系统是2G/2G 模式，在本实验中，UTOP以上的虚拟地址空间到物理地址的映射关系都是一样的。因此复制内核的boot_pgdir中UTOP以上的内容到pgdir中，在进入内核态时不需要切换CR3寄存器。 (2) ULIM划分了用户空间与内核空间，UTOP属于用户空间，但UTOP至ULIM的区域与其他用户区相比，用户只能读不能写，其由三个4M大小的空间组成，分别存放进程envs数组、pages数组、进程页表。 (3) UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间为4MB ，这一区域就是进程的页表的位置，而PDX(UVPT)就是页目录自映射所对应的页目录在页表中的位置，因此要让pgdir[PDX(UVPT)]=env_cr3。 (4) 不同进程有各自的虚拟空间，访问相同虚拟地址时得到的结果可能是不同的；对于不同的进程而言，虚拟地址ULIM 以上的地方虚拟地址到物理地址的映射关系都是一样的，方便内核对进程进行管理。 Exercise 3.5补充env_alloc，根据父进程生成子进程到new指针中，首先从env_free_list获取第一个空闲进程。 /*Step 1: Get a new Env from env_free_list*/if (LIST_EMPTY(&env_free_list)){ return -E_NO_FREE_ENV;}e = LIST_FIRST(&env_free_list); 接下来就要为这个纯洁的e进程分配地址空间，用之前写过的env_setup_vm实现映射。 r = env_setup_vm(e);if (r != 0){ panic(\"env_setup_vm failed!\");} 然后创建独一无二的ID，设置进程状态。ENV_RUNNABLE表明该进程处于就绪状态，正在等待被调度。 /*Step 3: Initialize every field of new Env with appropriate values.*/e->env_id = mkenvid(e);e->env_parent_id = parent_id;e->env_status = ENV_RUNNABLE; 接下来就是设置29号寄存器（SP寄存器，堆栈指针寄存器）和cp0寄存器（协处理器）的值，把e的值交给new，并从空闲进程链表中删去e。 /*Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */e->env_tf.regs[29] = USTACKTOP;e->env_tf.cp0_status = 0x10001004;*new = e;/*Step 5: Remove the new Env from env_free_list. */LIST_REMOVE(e, env_link); 世界是多么的美好啊！接下来就是本次实验的坑点了，虽然我Debug3天的原因是Lab2写错…… 加载二进制镜像我们需要为新进程的程序分配空间来容纳程序代码，这也是本次实验的大难点了。 Thinking 3.4思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子） 答： 不可以。在我们的实验中，与user_data有关的函数是load_icode、load_elf、load_icode_mapper，其中的user_data就是进程e的指针，是不可或缺的。 应用场景：load_icode_mapper是一个回调函数，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。C语言标准库中的排序qsort就用到了这种设计： void qsort(void*base,size_t num,size_t width,int(__cdecl*compare)(const void*,const void*)); 这之中的compare就是回调函数，两个形参是const void *型，有着很高的泛用性，与user_data的设计类似。 Exercise 3.6填充load_icode_mapper 函数。复制下助教的Lab3释疑解惑的内容，这样下次就不需要找PDF了。 struct Env *env = (struct Env *)user_data;struct Page *p = NULL;u_long i = 0;int r;u_long offset = va - ROUNDDOWN(va, BY2PG); 这个函数集前三个lab 知识之大成，一定要熟悉lab1 中的ELF 结构和lab2 中内存分配的方法！在填写这个函数之前，要先知道它是干什么的。我们现在已经完成实验的第三步— 创建进程中的第一小步，现在已经有了空进程，但只有骨架没有灵魂怎么行？一个进程是一个程序的一次运行，所以现在就要把程序装进给进程分配的内存空间中。 这一任务由load_icode 函数来完成，它的步骤就是分配内存，并将二进制代码装入分配好的内存中。但它一个函数要承担这么大的任务，有点吃不消啊。所以它就把装入内存的任务交给了load_elf 函数。但装入内存的任务还是有点艰巨，不仅要解析ELF 结构，还要把ELF 的内容复制到分配好的内存中。这函数比较懒，就又把内容复制的任务交给了load_icode_mapper。这下终于不再嵌套了，好像身体被掏空是不是？别急，先来看看这个函数。这个函数如果完成了，lab3 也就没啥难的了。 这个函数大体上也是两步走，第一步，复制ELF 的内容（当然，必须是代码段和全局数据段）。第二步就是难中之难，给ELF 的内容分配页面。 现在二进制码长度已经由它的参数bin_size 传入了。那又跑出一个段长度sgsize 是什么鬼？还记得lab1 的readelf 吧，二进制码长度bin_size 等于代码段.text 和全局数据段.data 长度之和，但不一定等于ELF 要占用的内存大小。回顾lab1 中的ELF 结构，代码段是通过program header 定位的，每个头部都有一个filesize 和memsize，就分别对应bin_size 和sgsize。别忘了ELF 中还有一个.bss 段哦，这.bss 段是全部要置零的，所以无需在ELF 中体现，但并不代表它就不占内存。那么请你想一下，bin_size 和sgsize 满足什么样的不等式？.bss 段的起始地址和bin_size 是什么关系？这是该函数的第一个难点。 前门狼刚走，后门虎又来。看看函数前面的说明，pre_condition 中有一条提示：va may NOT aligned 4KB。这提示了什么？lab2 中我们实现的是页式内存管理，一页的大小是4KB（BY2PG），也就是说，一个页的首地址的十六进制表示的后三位都是0。如果va 不是一个页的首地址，比如0x0003f2d4，该如何处理呢？那么同样的问题，如果.bss 段的首地址不是页对齐的，又该如何处理呢？提示：善于利用offset 变量。再给一个提示，在一段内存不满一个页（4KB）的情况下，仍然要分配一整个页来存储，就像出租车计费，就算你多走了100 米也会按1 公里算。 函数大致的作用是把大小为bin_size的*bin文件，拷贝到[va，va+sgsize]这个区间中，不足地方补零，在一段内存不满一个页（4KB）的情况下，仍然要分配一整个页来存储。由于va不一定对齐，拷贝分为三个步骤： 不对齐时，载入第一页： /*Step 1: load all content of bin into memory. *//*First, bin->[0,BY2PG-offset] to [offset,BY2PG]*/if (offset){ u_int32_t size = MIN(BY2PG - offset, bin_size); r = page_alloc(&p); if (r) return r; bcopy(&bin[i], page2kva(p) + offset, size); r = page_insert(env->env_pgdir, p, va, PTE_R); if (r) return r; i += size;} 载入第二页直到拷贝完整个文件，此时i始终与BY2PG对齐： while (i < bin_size){ u_int32_t size = MIN(BY2PG, bin_size - i); r = page_alloc(&p); if (r) return r; bcopy(&bin[i], page2kva(p), size); r = page_insert(env->env_pgdir, p, va + i, PTE_R); if (r) return r; i += MIN(BY2PG, sgsize - i);}// i = MIN(ROUND(bin_size, BY2PG),sgsize) 填充后面的0： /*Step 2: alloc pages to reach `sgsize` when `bin_size` < `sgsize`. * hint: variable `i` has the value of `bin_size` now! */while (i < sgsize){ u_int32_t size = MIN(BY2PG, sgsize - i); r = page_alloc(&p); if (r) return r; r = page_insert(env->env_pgdir, p, va + i, PTE_R); if (r) return r; // bzero(page2kva(p), size); // already bzero in page_alloc i += size;}return 0; 需要注意的就是填充0吧，i在最开始对齐之后就保持BY2PG步进，直到sgsize加载完毕。 这个在补充指导书里讲的还蛮详细的。在每一阶段，要做的都是申请页面、复制/填0、插入页表，而因为page_alloc就包含了bzero操作，实际补0只要申请页面然后加入页表就可以了。 Thinking 3.5结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？ （提示：1、页面大小是多少；2、回顾lab1中的ELF文件解析，什么时候需要自动填充.bss段） 答： 若va不对齐，拷贝长度要选择BY2PG - offset和bin_size中的最小值，复制第一页。 i < bin_size时，如果i < bin_size - BY2PG，那么就以BY2PG步进，复制每一页；如果出现了BY2PG > bin_size - i的情况，那么依然要分配一页的空间。 如果i仍然小于sgsize，需要继续申请页面并置0。 .bss 段是全部要置零，也就包含在置零的空间中。 Exercise 3.7通过补充的ELF 知识与注释，填充load_elf 函数和load_icode函数。 load_elf只要填map就好了—— r = map(phdr->p_vaddr, phdr->p_memsz, phdr->p_offset + binary, phdr->p_filesz, user_data); 这里的bin为什么是phdr->p_offset + binary呢？ typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address， 这就是需要映射的虚拟地址*/ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */} Elf32_Phdr; 参考ELF手册，此数据成员给出本段内容在文件中的位置，即段内容的开始位置相对于文件开头的偏移量。 load_icode首先设置用户用户栈，分配一页的空间在[UTOP，UTOP-BY2PG]区间。而我的问题就在于page_insert写错……啊啊啊啊啊理解不深入真的太惨了。 /*Step 1: alloc a page. */r = page_alloc(&p);if (r) panic(\"page_alloc in load_icode failed\");/*Step 2: Use appropriate perm to set initial stack for new Env. *//*Hint: Should the user-stack be writable? */r = page_insert(e->env_pgdir, p, USTACKTOP - BY2PG, perm);if (r) panic(\"page_insert in load_icode failed\"); 然后调用load_elf，套娃~ /*Step 3:load the binary using elf loader. */r = load_elf(binary, size, &entry_point, (void *)e, load_icode_mapper);if (r) panic(\"load_elf in load_icode failed\");/*Step 4:Set CPU's PC register as appropriate value. */e->env_tf.pc = entry_point; 最后记得设置PC寄存器到程序入口。关于这里引用学长的分析—— 那么下面来解释一下为什么这里用的是page2kva(page)，而不是用与UTEXT有关的数值？ 首先我们解释过了，UTEXT+0xb0是程序的入口，何谓入口？比如我们现在启动了一个进程，我们如何能从哪里开始，该怎样跑呢？这取决于我们run一个进程前的准备工作，当然这个工作在进程切换时也需要做，其中很重要的一点就是保存pc。这一点很重要，极其重要。如果是第一次run一个进程的时候，我们的pc是务必要被设置为UTEXT+0xb0的，这也是在env_alloc里面所做的工作。之后有一些我们没有关注过的汇编程序就会默默地根据我们设置的pc去找我们的程序入口，默默地执行，遇到中断默默地保存，切换。于是就这样完成了进程的运行与切换大计。 那么我们这里bcopy不能用UTEXT来copy是因为，我们这里还没开始一个进程，没有其页目录来作为基址，所以你现在copy到的地方也只是内核的UTEXT处。我们都知道在env_run时要切换页目录，切换为进程的页目录后，我们就再也找不到这部分copy的东西了（因为env_setup_vm只复制内核页目录ULIM以上的部分）。所以我们要copy到的地方一定是要内核和每个进程均可以访问的，显而易见要copy到ULIM以上的部分。即page2kva(page)这个地方。当然，你可以选择先切换到进程的页目录，然后copy，然后在结束的时候切换回内核的页目录，再次强调一点，bcopy也好，bzero也好，在我们编写的程序中，只要是作为访问地址来使用的（什么叫作为地址来使用，就是可以取其内容的 *address)，全部都使用的是虚拟地址！ Thinking 3.6思考上面这一段话，并根据自己在lab2 中的理解，回答： 我们这里出现的” 指令位置” 的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？ 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？ 答： (1) 虚拟空间。当我们运行进程时，CPU 将自动从pc所指的位置开始执行二进制码，此时的空间是连续的，而虚拟空间对应的物理内存可能是不连续的，因此是虚拟空间。 (2) 一样。每个进程都有独立的虚拟空间，因此entry_point其值对于每个进程一样，是程序入口；但entry_point实际映射的物理地址不同。 创建进程终于结束了最难的部分……下面来看看进程的创建吧！ Exercise 3.8完成env_create 函数与env_create_priority 的填写。 void env_create_priority(u_char *binary, int size, int priority){ struct Env *e; /*Step 1: Use env_alloc to alloc a new env. */ int r; r = env_alloc(&e, 0); if (r) panic(\"env_alloc in env_create_priority failed\"); /*Step 2: assign priority to the new env. */ e->env_pri = priority; /*Step 3: Use load_icode() to load the named elf binary, and insert it into env_sched_list using LIST_INSERT_HEAD. */ load_icode(e, binary, size); LIST_INSERT_HEAD(&env_sched_list[0], e, env_sched_link);} 先用env_alloc创建一个新进程，由于没有父进程，所以就把父进程id设置为0；然后设置进程优先级；最后调用load_icode载入二进制程序文件。为了调度，将进程插入到env_sched_list[0]中。 void env_create(u_char *binary, int size){ /*Step 1: Use env_create_priority to alloc a new env with priority 1 */ env_create_priority(binary, size, 1);} env_create只要调用env_create_priority就好了。 Exercise 3.9在这次实验中我们没有用到env_create，而是用了一个宏—— #define ENV_CREATE_PRIORITY(x, y) \\{\\ extern u_char binary_##x##_start[]; \\ extern u_int binary_##x##_size;\\ env_create_priority(binary_##x##_start, \\ (u_int)binary_##x##_size, y);\\} ENV_CREATE_PRIORITY(x,y)等价于env_create_priority(binary_x_start,binary_x_size,y)。 进程运行与切换env_run是进程运行使用的基本函数，它包括两部分： 保存当前进程上下文(如果当前没有运行的进程就跳过这一步) 恢复要启动的进程的上下文，然后运行该进程。 Thinking 3.7思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？ 答： 要保存的进程上下文中的env_tf.pc的值应该设置为cp0_epc，从而从被中断的指令继续运行。 Thinking 3.8思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题： 请给出一个你认为合适的TIMESTACK 的定义 请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析) 思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同 答： (1) TIMESTACK以下[TIMESTACK - sizeof(struct Trapframe), TIMESTACK)的空间存储着异常发生时的寄存器信息，是时钟中断后的存储区。 (2) 在include/stackframe.h中可以找到： .macro get_sp mfc0 k1, CP0_CAUSE andi k1, 0x107C xori k1, 0x1000 bnez k1, 1f nop li sp, 0x82000000 j 2f nop1: bltz sp, 2f nop lw sp, KERNEL_SP nop2: nop.endm 其中的0x82000000即TIMESTACK的值。本次实验产生的都是时钟中断，进行的是li sp, 0x82000000的操作，因此是时钟中断后的存储区。 (3) TIMESTACK是时钟中断后的存储区，而KERNEL_SP应当是系统调用后的存储区。 Exercise 3.10根据补充说明，填充完成env_run 函数。 void env_run(struct Env *e){ /*Step 1: save register state of curenv. */ /* Hint: if there is an environment running, you should do * switch the context and save the registers. You can imitate env_destroy() 's behaviors.*/ if (curenv) { struct Trapframe *old; old = (struct Trapframe *)(TIMESTACK - sizeof(struct Trapframe)); bcopy(old, &(curenv->env_tf), sizeof(struct Trapframe)); curenv->env_tf.pc = curenv->env_tf.cp0_epc; } // 保存当前进程的上下文信息，设置当前进程上下文中的 pc 为合适的值。 /*Step 2: Set 'curenv' to the new environment. */ curenv = e; // 把当前进程 curenv 切换为需要运行的进程。 /*Step 3: Use lcontext() to switch to its address space. */ lcontext(e->env_pgdir); // 调用 lcontext 函数，设置进程的地址空间。 /*Step 4: Use env_pop_tf() to restore the environment's * environment registers and return to user mode. * * Hint: You should use GET_ENV_ASID there. Think why? * (read , page 135-144) */ env_pop_tf(&(curenv->env_tf), GET_ENV_ASID(curenv->env_id)); // 调用 env_pop_tf 函数，恢复现场、异常返回。} env_pop_tf把env里的tf压到寄存器中，进行返回，需要先设置lcontext切换进程页目录。 异常的分发这一部分表面要做复读机，但代码理解起来好痛苦……啊啊啊我已经写了两天这个博客啦，这也太难过了为什么这么多不会根本理解不完啊…… Exercise 3.11将异常分发代码填入boot/start.S 合适的部分， .section .text.exc_vec3NESTED(except_vec3, 0, sp) .set noat .set noreorder1: mfc0 k1,CP0_CAUSE la k0,exception_handlers andi k1,0x7c addu k0,k1 lw k0,(k0) nop jr k0 nopEND(except_vec3).set at 这段异常分发代码的作用流程简述如下： 取得异常码，这是区别不同异常的重要标志。 以得到的异常码作为索引去exception_handlers 数组中找到对应的中断处理函数，后文中会有涉及。 跳转到对应的中断处理函数中，从而响应了异常，并将异常交给了对应的异常处理函数去处理 Exercise 3.12将lds 代码补全使得异常后可以跳到异常分发代码，0x80000080地址存放的是异常处理程序的入口地址。 . = 0x80000080;.except_vec3 : { *(.text.exc_vec3)} 这里将.text.exec_vec3 放到0x80000080，一旦异常发生，就会引起该段代码的执行。 异常向量组填空题：阅读see-mips-run-linux中的关于异常码与异常类型的对应关系部分。 算数异常(OV)如加法溢出、减法溢出等异常，其对应的异常码为12。（来源：P78） 时钟中断初始化时钟主要是在kclock_init 函数中，该函数主要调用set_timer函数。 Exercise 3.13补充kclock_init 函数。 /*** exercise 3.13 ***/voidkclock_init(void){ // hint: use set_timer() set_timer();} 虽然不是很理解但只要填就对了呢…… Thinking 3.9阅读 kclock_asm.S 文件并说出每行汇编代码的作用。 答： .macro setup_c0_status set clr // 定义宏setup_c0_status，传入set置位和clr清零形参 .set push // 保存现场 mfc0 t0, CP0_STATUS // 读CP0_STATUS的值到t0寄存器 or t0, \\set|\\clr // t0=(t0|set|clr)，将set为1的置1 xor t0, \\clr // t0= xor(t0,clr)，将clr为1的置0 mtc0 t0, CP0_STATUS // 将t0寄存器写回CP0_STATUS .set pop // 恢复现场.endm // 结束宏语句 .text // 代码段LEAF(set_timer) // LEAF定义不调用其他函数的叶子函数set_timer li t0, 0x01 // t0设为1 sb t0, 0xb5000100 // 设置实时钟中断的频率为1秒1次 sw sp, KERNEL_SP // 保存栈的值到KERNEL_SPsetup_c0_status STATUS_CU0|0x1001 0 // 设置CP0_STATUS jr ra // 函数返回 nop // 延迟槽END(set_timer) // 结束函数 进程调度最后一章了！ Exercise 3.14根据注释，完成sched_yield 函数的补充，并根据调度方法对 env.c 中的部分函数进行修改，使得进程能够被正确调度。 void sched_yield(void){ static int count = 0; // remaining time slices of current env static int point = 0; // current env_sched_list index static struct Env *e; while (count == 0) { if (LIST_EMPTY(&env_sched_list[point])) { point = 1 - point; } e = LIST_FIRST(&env_sched_list[point]); count = curenv->env_pri; LIST_REMOVE(e, env_sched_link); LIST_INSERT_HEAD(&env_sched_list[1 - point], e, env_sched_link); } count--; env_run(e);} 参考Ausar的写法写的，马上的Thinking 3.10就要让我重新思考一遍。 Thinking 3.10阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。 答： 首先在set_timer设置实时钟中断的频率，实验中为1秒1次。 一旦实时钟中断产生，就会触发MIPS 4号中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。 通过text.exc_vec3代码段的分发，调用handle_ int 函数来处理实时钟中断。 在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq。 在timer_ irq里跳转到sched_ yield，如果当前进程的时间片用完了，则切换到下一个进程。 总结啊，抄完了，虚脱的感觉，我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 我就是啥也不会的FW。 认真你就输了。 工作你就输了。 我输了。 2020/4/25 21:02 无可救药的码呆茶","permalink":"https://mondaycha.github.io/2020/04/24/424-1/","photos":[]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week8","date":"2020/04/23","text":"爱课程 6.1 液体火箭发动机今天课堂的内容是航天器发展的基础——火箭发动机，首先是液体火箭发动机，有挤压式和泵式的推进剂输送系统，推力室是火箭发动机的关键部件，液体火箭发动机的两种推进剂是放在储箱里面的。 爱课程 6.2 固体火箭发动机在这节课我了解到，固体火箭发动机的结构更加简单。固体火箭发动机的推力矢量控制是很重要的一个因素：有燃气舵、二次喷射技术、双向摆动喷管、全轴摆动喷管等技术。发动机还需要推力终止装置，进行释压。推力大小上，有一维药柱、二维药柱、三维药柱等以进行控制。 爱课程 6.3 非常规火箭发动机液体火箭发动机和固体火箭发动机都属于化学推进系统，效率低、比冲低，因此各国也在大力发展非化学推进系统的非常规火箭发动机。如核推进、太阳能推进、电推进（静电推进、电磁推进等）等。 学堂在线 8 导航、制导和测控技术在这节课我了解到，导航自古存在，远古时代就有恒星导航，指南针的发明也是早期的导航手段。导航可以提供的信息包括位置信息、方位信息、速度信息等。卫星导航系统一般包括卫星系统、地面站组、用户设备等组成部分，北斗导航是世界四大卫星导航系统中唯一具有短报文通信功能的导航系统。 火箭发动机的排放是否存在污染问题？为什么？存在。固体火箭发动机在燃烧的时候，会产生氧化铝固体颗粒粉尘以及盐酸雨雾。火箭烟尘积聚在平流层上部，粒子吸收太阳光。他补充说，这种积聚会加热平流层上层，改变化学反应速率，并可能导致臭氧损失。在燃烧不完全下，也完全可能产生一些其他对环境有污染的燃烧副产物。 当航天行业成为更加平民化、更加普及的产业时，相信这些问题也将得以克服。 为什么说景象匹配的导航精度优于地形匹配？地形匹配制导技术的工作原理是在导弹发射区与目标区之间选择几个特征明显的标志区，通过遥测、遥感手段，按其地面坐标点标高数据绘制成数字地图；景象匹配导航技术利用弹载“景象匹配区域相关器”获取目标区域景物图像数字地图，将其与预存的参考图像进行相关处理，从而确定导弹相对于目标的位置。从数字地图构建上景象匹配优于地形匹配，因此景象匹配的导航精度优于地形匹配。","permalink":"https://mondaycha.github.io/2020/04/23/423-1/","photos":[]},{"tags":[{"name":"机械键盘","slug":"机械键盘","permalink":"https://mondaycha.github.io/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"},{"name":"杜伽","slug":"杜伽","permalink":"https://mondaycha.github.io/tags/%E6%9D%9C%E4%BC%BD/"}],"categories":[{"name":"测评","slug":"测评","permalink":"https://mondaycha.github.io/categories/%E6%B5%8B%E8%AF%84/"}],"title":"杜伽 K320 深空灰白光限定版 测评","date":"2020/04/22","text":"前言作为机械键盘界的后起之秀，杜伽的口碑也一直不错，主打的产品线K320历经多次打磨，还有那么几分不将就的意味。 K320也有多个版本：在87经典配列的基础上，K320（无光、双色不透光闭口字符PBT）、K320 日冕（双色开口字符PBT）、K320 Aurora（有两种发光源）、K320粉色白光限定版（ABS键帽）、K320 Nebula（RGB同步）、K320W（无线三模）以及今天的主角K320 深空灰白光限定版。 虽说是限定，现在要买到还是挺容易的，和普通的 K320 白光对比，限定版的区别主要是采用了原厂高度的深空灰配色PBT双色注塑闭口字符键帽。下面就带来我的体验。 开箱外观▼ 先来简单开个箱。K320 深空灰白光限定版的包装延续了杜伽一贯的蓝黑风格，整体包装也很简洁，左下角则是“TAURUS K320”的标识，这次我选择的是CHEERY最经典的红轴。 TAURUS即金牛座，用星座命名产品也是杜伽的特色之一，比如杜伽键盘系列用到的金牛座（TAURUS）与双子座（GEMINI），或者是鼠标中的狮子座（LEO）。 ▼ 左上角有“White/白光”的贴纸，限定版与普通白光版相比，主要差别或许在键帽配色（深空灰）与键帽高度（原厂高度）以及字符开闭（双色注塑闭口字符）。 ▼ 值得一提的是，杜伽全系产品采用的Zeus驱动是通过了Windows 10 Compatible认证的，这一点在安装驱动之后还有小惊喜。 ▼ 翻开上盖，键盘在防尘罩下等待。另外还赠送了一个小杯垫，连接线等则隐藏在蓝色的瓦楞纸板下，与键盘主体分割，也使得键盘不会显得过于凌乱。 ▼ 内部配件一览，包括键盘本体、防尘罩、拔键器、USB-A to USB-C数据线和USB-C to USB-C数据线、束线器、贴纸、用户指南等。 配件▼ 随机附带了两种数据线——USB-A to USB-C数据线和USB-C to USB-C数据线，都是橡胶材质。其中C to C较短，A to C 则带有屏蔽环，可以适应不同的需求。 ▼ 赠送的杯垫，采用鼠标垫同款材质，实测防滑效果也不错。 ▼ 钢丝拔键器，比起塑料拔键器对键帽的损伤更低一些，上面同样有杜伽的LOGO。 此外还有建议看看的说明书和不知道该怎么用的贴纸……魔术贴扎带可以收纳线材，不过我一般直接隐藏在电脑背面，也就很少用到。 外观▼ 看到K320 深空灰白光版的第一眼，最给我以冲击的或许就是那仿金属磨砂的塑料面板了。面板整体为深褐色，虽然是塑料材质，但磨砂处理后的质感却非常棒。 ▼ 背面也是一样，边缘没有多余的毛刺，前后面板采用卡扣连接，整体十分协调，抚摸时的手感也如丝绸般顺滑。 ▼ 背面的三向导线槽，出线口为USB-C接口。喷漆细腻，反光也比较明显。 ▼ 两段式脚撑，键线分离、三向导线槽以及两段式脚撑也算是现在87键机械键盘的标配了。 ▼ 右下角是杜伽的LOGO，键帽采用悬浮式设计。另外K320的厚度在我用过的机械键盘里算是较薄的那一类，不需要腕托也可以舒服地使用。 深空灰键帽的手感同样很赞，采用PBT双色注塑工艺，不用担心正面磨花的风险；虽说ABS的手感比起PBT往往更加丝滑，但打油起来也是毫不留情。而杜伽这套键帽应该也是由Hardcap出品，加上磨砂处理的键帽的手感比起ABS也是不遑多让，怎么说呢……仿佛肌肤般的质感？ ▼ 键帽字符特写，闭口字符纤细而富有美感，不过注塑的半透明字符在边缘处有一些光线削减效应，给人以一种颜色不均匀的感觉，具体还是要等亮灯了再看看。 ▼ 键帽上侧刻的功能按键与灯光调节示意。K320的功能按键功能极其丰富——播放暂停、切歌、音量加减、静音……还可以在驱动中进行自定义操作。 ▼ 用拔键器取下键帽，方方正正四角尖尖，结合细磨砂的外表面，仿佛还未被磨平棱角的顽石。我之前用的主要是OEM高度，此次也是初次尝试原厂高度，感觉更平坦一些。如果习惯了OEM高度，也许需要一段时间适应，K320限定版的键帽与OEM高度键帽对比如下—— ▼ 轴体是CHERRY 红轴，杜伽的银轴口碑颇为不错，不过红轴也许更适合推荐给刚开始接触机械键盘的人使用，轴体上方则是白色灯珠。 ▼ 大键部分采用的是卫星轴，还可以看到润滑脂。轴体下方还有白色钢板，在亮灯后也能形成不错的氛围（又称漏光）。大键的用料也很扎实，不过水口也比较明显。 总的来说，K320的做工还是不错的，小遗憾或许就在于键帽字符透光不均匀，不得不说细磨砂的质感真的吹爆~ 使用体验之前只体验过杜伽的无光版键盘，而这次的白光版则给了我很多无法以参数体现的惊喜。 不过在短篇大论之前先说说手感——键帽本身的磨砂材质自然是一大加分项；而大键的调教也算不错，虽然部分按键（比如我手头这把的BackSpace）的就肉感明显，可能还需要多适应，但空格等就十分干净利落。红轴的体验就不用多说，内置钢板也让K320有着恰到好处的反馈。 灯光▼ 键盘有四枚指示灯，依次为大小写锁定、ScrLk、Win键锁定以及自定义配置文件的调用。 而第一个参数上无法反映的细节——在用Fn+功能键进行调节时，当调节到了MAX或MIN值时，K320会同时点亮四枚指示灯以示意—— 另外不管之前处于何种灯光模式，在按住Fn键时，K320会自动以最大亮度点亮功能键，同时熄灭其它按键—— 虽然这些功能一般来说使用频率不高，但从中还是能看到设计团队的用心。 ▼ K320白光限定版的白光有些偏紫，而且颇为遗憾的一点是对于部分字符较长的大键位，透光并不均匀。 这一问题在杜伽的K320基础版（虽然不透光）就能有一定的解决——大键位采用符号表示字符。 ▼ 内置11种灯光模式，支持10级亮度调节，还可以进行自定义灯光。不过我个人最常用的就是常亮了（如果是RGB键盘则是常亮循环），其他也就图一时新鲜，实际使用容易分心…… 已有的灯光模式还可以用Fn+PgUp/PgDn进行个性化调整，如果不想要灯光可以使用Fn+Del关闭。 驱动说完灯光再来聊聊驱动，驱动Zeus可在官网下载，支持杜伽的大部分产品。 前面提到的Windows 10 Compatible认证的妙处这里就体现出来了，安装好驱动后，在设备管理器就可以看到产品名称，适配做的不错。 在驱动内可以设置灯光模式，另外还能够录制按键。 对于一些不常用的按键，可以重新定义功能。在键盘上Fn+F12切换到自定义配置。 总结个人觉得杜伽 K320 深空灰白光限定版还是很有料的一把键盘，让人感到诚意的就是其磨砂材质带来的优秀手感，以及改善用户体验的种种小细节。 而不足之处，大键字符过长透光不均匀要减分。不过在这个价位，K320 深空灰白光版还是很有吸引力的，希望之后杜伽也能推出更多好产品吧。 以上，我是码呆茶，谢谢观看~","permalink":"https://mondaycha.github.io/2020/04/22/422-1/","photos":["http://pb3.pstatp.com/large/pgc-image/f9933fad2de74b438945f1e8a9f7e8d9"]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week7","date":"2020/04/16","text":"爱课程 4.3 航天器的飞行原理航天器遵循天体力学（主要是轨道动力学的支配），与航空不一样，航天器的出现使人类的活动范围从地球大气层扩大到广阔无垠的宇宙空间，。人造天体与自然天体的最大区别是轨道机动。 爱课程 5.1 活塞式发动机活塞式发动机目前主要用于小型低速飞机。活塞式发动机主要由气缸、活塞、连杆、曲轴、气门机构、螺旋桨减速器、机匣等组成。除了这些主要部件外，还需要若干辅助系统。除此以外，另外一类就是空气喷气发动机。 爱课程 5.2 涡轮喷气发动机超音速进气道中调节锥的作用是产生斜激波，降低气流速度。现在用的最多的是轴流式发动机，逐级使压力增大，在燃烧室，为了使空气与燃料稳定接触，通过喷嘴雾化和涡轮将高温等转变为机械能。用在歼击机上的涡轮风扇发动机的涵道比与民用飞机上的相比一般要小。 爱课程 5.3 其他发动机在这一节我学习到，对于一些速度并不快或高速的情况，除了活塞式发动机、涡轮喷气发动机，可以使用其他类型的航空发动机，来平摊经济成本。冲压喷气发动机由进气道、燃烧室、尾喷管组成。 学堂在线 7 发射与回收技术航天器发射中，需要发射窗口，发射窗口需要满足很多条件。航天器的再入方式也有多种，纯弹道式在技术上容易实现，采用半弹道式再入方式再入的航天器包括神舟系列飞船和联盟号飞船，另外还有滑翔式。 为什么航天器要在发射窗口发射？发射窗口是指运载火箭发射比较合适的一个时间范围，由于每个航天器承担的任务不同，航天器上安装的仪器，设备使用要求不同，它们对发射窗口提出了种种要求和限制条件，而这些要求有时又互相矛盾，因此选择什么时间发射就必须考虑各方面的要求，经综合平衡后选择一个比较合适的发射窗口。 喷气式发动机产生推力是否符合牛顿第三定律？当然符合。牛顿第三定律揭示，作用在一物体上的每一个力都有一方向相反大小相等的反作用力。喷气发动机用类似于发动机/螺旋桨组合的方式产生推力。二者均靠将大量气体向后推来推进飞机。","permalink":"https://mondaycha.github.io/2020/04/16/416-1/","photos":[]},{"tags":[{"name":"冯如杯","slug":"冯如杯","permalink":"https://mondaycha.github.io/tags/%E5%86%AF%E5%A6%82%E6%9D%AF/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"冯如杯创业大赛第一次修改意见","date":"2020/04/16","text":"1、文中列举的数据和插图最好都说明来源 2、专有名词在策划书中第一次出现时需要用全称非缩写，增强整体可读性 3、竞争产品分析中，需要对产品进一步剖析，通过现有产品的局限突出自己产品的优势 4、市场分析角度不够广，还可以加入对目标顾客群体的分析、营销策略的选择等等 5、前一半是科技论文的写法，需要进行修改，目前在策划书里显得生硬","permalink":"https://mondaycha.github.io/2020/04/16/419-1/","photos":[]},{"tags":[{"name":"冯如杯","slug":"冯如杯","permalink":"https://mondaycha.github.io/tags/%E5%86%AF%E5%A6%82%E6%9D%AF/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"冯如杯创业大赛-风险投资部分","date":"2020/04/16","text":"风险因素技术风险 市场风险 管理风险 财务风险 其他不可预见的风险 风险投资的退出方式股票上市：依照商业计划的分析，公司上市的可能性做出分析，对上市的前提条件做出说明 股权转让：投资商可以通过股权转让的方式收回投资 股权回购：依照事业商业计划的分析，公司对实施股权回购计划应向投资者说明 利润分红：投资商可以通过公司利润分红达到。收回投资的目的，按照本商业计划的分析，公司对实施股权利润分红计划应向投资者说明","permalink":"https://mondaycha.github.io/2020/04/16/421-1/","photos":[]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week6","date":"2020/04/09","text":"爱课程 3.2 飞机飞行性能在这节课我学习到，由于流程之间有内摩擦，在靠近管壁的时候流速慢一点。空气和空气之间的流程会产生摩擦，空气与飞行器的表面也会产生摩擦。空气的粘性低表面光滑度，气流流动状态，体表面积大小都是粘性摩擦阻力的影响因素。相同的迎风截面积条件下，不同形状和尺寸的物体上有相同的阻力。 爱课程 3.3 飞机操纵性与稳定性在这节课我学习到，飞机的三种操纵、飞机的稳定性。比如说古代的箭尾部增加羽毛，重心与焦点位置，重心越靠前越稳定，这是纵向稳定性；而方向稳定性以及横向稳定性也有各自的依据。另一个指标则是机动性，与稳定性不可兼得。 爱课程 4.1 直升机的飞行在这节课我学习到，直升机采用旋转机翼，与固定翼不一样。直升机相比固定翼，可以垂直起降、空中悬停等，有着自己的优势。直升机旋翼的工作原理，反作用力矩，为了平衡这个反作用力，直升机有了很多细分的类别，由尾桨、双旋、带翼、倾转、旋转定翼等方式实现平衡。 爱课程 4.2 直升机的操纵在这节课我学习到，直升机的操纵也比固定翼要复杂很多。有总距操纵、变距操纵、前飞操纵、航向操纵等。直升机的稳定性差，悬停操纵也不是一件简单的事情。无人机的动力学特性比较复杂，对驾驶员也有很高的要求，危险程度大。 学堂在线 6.4/6.5 无人机的发射与起飞/无人机的回收与着陆在学堂在线的这一节我学习到，无人机是一个很有发展前景的航空器（虽然昨日刚刚曝出大疆裁员的消息，2020的新冠对各行各业都是严峻的挑战）。无人机的起飞有多种发射方式，比如有零长度发射、载机空中发射、垂直起飞、人力投掷等。无人机的回收方式也有多种，比起飞更有挑战，需要注意对机上设备的保护。 歼-15是什么气动布局？为什么采用这样的布局？歼15是以T10K原型机为基础研制的一代国产舰载战斗机， 气动布局：气动外形类似于苏联（俄罗斯）的苏33舰载战斗机。歼15是双发，双垂尾的重型战斗机，带鸭翼的三翼面气动布局，带有着舰拦阻钩，采用电传飞行控制系统，具有优异的机动性能。 采用原因：适应舰载战斗机的作战需求，便于实现折叠机翼等功能。 飞机操纵性和稳定性之间有什么关系？在其他条件不变之下,稳定性大的飞机操纵起来就一定费力些，两者不可兼得。其中稳定性需要飞机重心适当靠前，操作性需要飞机重心适当靠后。在两个要求的重叠范围内，就是飞机起飞前配载工作的主要目的。","permalink":"https://mondaycha.github.io/2020/04/09/409-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"2020 OO 第二单元总结","date":"2020/04/09","text":"只要跑得够快即使从头关到尾你也喜欢吗一、设计策略1.1 总体策略概述在多线程的协同和同步控制方面，我三次作业都是采用生产者/消费者模式（还憨憨地在内部分了customer、producer、tray的包……方便自己看orz）。 其中“生产者”为输入线程，将读取到的Request放到“货架”Scheduler上；“消费者”则是每个电梯线程，以一种类似观察者模式的方式追踪“货架”Scheduler的变化。之所以说是类似，是因为我每次都是在电梯自身状态发生改变后获取当前的“货架”Scheduler内容，而不是Scheduler一有更新就通知Elevator（也可能这是某种设计模式但我不知道）。 这样设计的好处是，我只有Scheduler类的方法是上锁的，其他类调用时不需要考虑是否会引发线程不安全问题，写起来很方便；坏处是我现在还不是很熟悉lock的用法…… 电梯内部则采用状态模式，设置了WAIT, OPEN, CLOSE, CLOSED, PASS, UP, DOWN多个枚举状态类型。 而对于对于存储人群信息的队列，我采用了单独的WaitMul、ElevatorMul封装HashMap的方式，指向来去楼层，并配置各种方法，外部可以对Multitude进行塞人取人的操作，Multitude内部的存储方式是不透明的。 1.2 性能优化策略1.2.1 第五次作业性能上，本次作业我采用的是在SSTF的基础上，自己瞎琢磨的“选择最短路径”贪心算法，比较电梯原目标与反方向新目标的最短距离： private static int minDistance(int cntFloor, int goalFloor, int tmpFloor, int tmpGoal) { int dis1 = Math.abs(goalFloor - cntFloor) + Math.abs(goalFloor - tmpFloor) + Math.abs(tmpGoal - tmpFloor); int dis2 = Math.abs(cntFloor - tmpFloor) + Math.abs(tmpGoal - tmpFloor) + Math.abs(goalFloor - tmpGoal); if (dis1 > dis2) { return tmpGoal; } else { return goalFloor; }} 然而这种方法有很大的缺陷……在某些特定楼层会有小几率出现反复横跳……最后逼近截止时间一直在改，又增加了防止锁死的机制（当检测到死循环时弃用这一优化），代价是拉低了性能，最后性能分16多。 1.2.2 第六次作业感谢CJB，他在第五次作业得到很高的性能分，也慷概地将他的算法分享给了我们—— sstf的基础上，当电梯里有人时候，选择最近上楼或最近出楼层的，就行，其他不变。 ​ ——《CJB语录》第二卷上册 所以在第六次多电梯，我的单电梯也采用了相同（也许）的策略。 /*************** * SSTF * *************/private int getGoalFloor(int cnt, boolean isEleFull) { // 传入参数：电梯当前楼层、电梯满员状态 if (elevator.isEmpty()) { return scheduler.getMinDisWhenEmpty(cnt, eleId); // 电梯为空时，按情况进入wait状态 } else { int inReq = elevator.getMinDisReq(cnt, goalFloor); if (isEleFull) { return inReq; // 电梯满员时，不考虑外部新请求 } int outReq = scheduler.getMinDis(cnt, inReq, eleId); if (outReq == LOST) { return inReq; // 外部没有请求，直接相应内部请求 } else { return Math.abs(outReq - cnt) < Math.abs(inReq - cnt) ? outReq : inReq; // 选择最近上楼或最近出电梯的 } }} 射射CJB！CJB, YYDS! 最后性能分19多。 1.2.3 第七次作业在第七次作业沿用了CJB的SSTF策略以及部分，为啥不用LOOK呢？我感觉这种性能分权重还是优先接人收益高。 而对于换乘，我用到了两组数组： private static final int[][] canStopOfType = { /*********1***********************9****************15****************/ {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1}, {0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0} /*********1***********************9****************15****************/};private static final int[][] mustFromName = { /********(1)**********************9***************(15)***************/ {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1}, {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0} /*********1***********************9****************15****************/};/*** A B C ***/ canStopOfType存储的是电梯可以停的楼层，mustFromName数组则是电梯必须接受这一楼层的请求（1和15层三个类型都可以，就让电梯自由竞争）。 换乘时会把人从电梯重新塞进等待队列，所以之后就与没有换乘的情况一样了。其实感觉5层作为换乘站也不错……后来不想改了……最后性能分19多。 二、可扩展性(2)从功能设计和性能设计的平衡方面，更细和总结自己第三次作业架构设计的可扩展性 可扩展性方面，这一次一开始就希望能为后续的扩展留好迭代空间，在正式开始之前读了好多学长的博客，其中PMXM助教的博客给了我很大启发： https://www.cnblogs.com/i-love-ange-and-oo-forever/p/10756828.html 最后迭代开发的效果还算马马虎虎……但每次加入新功能都会引入不少Bug，测试花的时间很多。 功能设计电梯是一台有限状态机，有WAIT, OPEN, CLOSE, CLOSED, PASS, UP, DOWN一共7种状态，三次作业的状态转移图都差不多，如下：![](G:\\OneDrive\\OneDrive - buaa.edu.cn\\MWD\\学习\\面向对象设计与构造\\博客2\\电梯流程图.jpg) 这样做的优势是每部电梯自身都独挡一面，人可以随时选择最近的电梯、呼叫多部电梯，方便增加电梯数量的扩展。 性能设计根据上面那个丑哭的状态转移图可知，在CLOSED, PASS两种状态下会调用获取目标楼层的方法，因此我所有的优化都只要写在获取目标楼层的方法getGoalFloor中，同样有利于迭代开发，比如第七次作业的getGoalFloor方法和前面提到过的第六次作业getGoalFloor方法比较，完全没有变化。 SOLID原则分析以第七次作业分析： SRP原则：感觉还行，RequestParser将读取到的PersonRequest放到Scheduler上，ElevatorRequest则传入Controller用于创造新电梯；ElevatorController运送Scheduler上的乘客。 OCP原则：电梯封装的好，便于扩展数量，感觉这方面还行。 LSP原则：在第五次作业，对于WaitMul、ElevatorMul采用了继承的方式，但后来在第六、七次作业的优化中取消……所以应该没有怎么实现。 LOD原则：RequestParser与ElevatorController通过Scheduler转发调用，有独立性。 ISP原则：在本单元作业没有创建接口，部分线程实现了Runnable接口。三种电梯我是采用构造时传参的方式，配置工厂类Controller用于创造新电梯，所以也就没有实现接口的必要了。 DIP原则：感觉做的还可以……因为我都是人自己刷新要乘坐的电梯（但是因为没有给人开线程，所以都是由电梯调用人的选电梯方法，其实实现上来说更类似于电梯抢人），避免了为了优化带来的倒置依赖。 三、度量分析3.1 第五次作业▼ 基本结构图，MainClass启动输入线程和电梯线程，外部的楼层等待人群和内部的电梯货运人群采用了继承抽象类人群的方式，将对人的存储方式封装起来。 ▼ 时序图，用插件自动生成的，感觉不是很准确……感觉参看我的有限状态机图更好一点…… ▼ 依赖关系，还可以。 Class Cyclic Dcy Dcy* Dpt Dpt* homework.MainClass 0 3 10 0 0 homework.custumer.Elevator 0 4 5 1 2 homework.custumer.Elevator.Status 0 0 0 2 3 homework.custumer.ElevatorController 0 3 8 1 1 homework.producer.RequestParser 0 2 5 1 1 homework.tray.MulInside 0 3 3 1 3 homework.tray.MulOutside 0 3 3 1 4 homework.tray.Multitude 0 2 2 4 7 homework.tray.Multitude.Type 0 0 0 3 8 homework.tray.Person 0 0 0 6 8 homework.tray.Scheduler 0 3 4 3 3 ▼ 复杂度，ElevatorController作为一台大状态机以及“抢人”的独立个体，自身的run方法作为状态机判断条件很多，圈复杂度也飘红；获取最优目标的getGoal方法这次写的很复杂…… Method ev(G) iv(G) v(G) homework.MainClass.main(String[]) 1 1 1 homework.custumer.Elevator.Elevator() 1 1 1 homework.custumer.Elevator.close(HashMap) 1 1 1 homework.custumer.Elevator.getCurrentFloor() 1 1 1 homework.custumer.Elevator.getMinTimeReq(int,int) 1 1 1 homework.custumer.Elevator.getStatus() 1 1 1 homework.custumer.Elevator.isEmpty() 1 1 1 homework.custumer.Elevator.move(boolean) 1 4 4 homework.custumer.Elevator.open() 1 1 1 homework.custumer.Elevator.setStatus(Status) 1 1 1 homework.custumer.Elevator.sleepTime(int) 1 1 2 homework.custumer.ElevatorController.ElevatorController(Scheduler) 1 1 1 homework.custumer.ElevatorController.getGoal1(int) 5 3 5 homework.custumer.ElevatorController.getGoal2(int) 6 3 7 homework.custumer.ElevatorController.getGoalFloor(int) 1 1 1 homework.custumer.ElevatorController.getGoalFloor2(int) 2 2 2 homework.custumer.ElevatorController.moveJudge(int) 2 2 6 homework.custumer.ElevatorController.run() 2 8 15 homework.custumer.ElevatorController.setDie2(boolean) 2 1 10 homework.producer.RequestParser.RequestParser(Scheduler) 1 1 1 homework.producer.RequestParser.run() 3 3 4 homework.tray.MulInside.MulInside() 1 1 1 homework.tray.MulInside.addInsideMul(HashMap) 1 2 2 homework.tray.MulInside.makeMultitudeOut(int) 1 2 2 homework.tray.MulOutside.MulOutside() 1 1 1 homework.tray.MulOutside.addOutsideMul(Person) 1 1 1 homework.tray.Multitude.Multitude(Type) 1 2 2 homework.tray.Multitude.cloneMulInFloor(int) 1 2 2 homework.tray.Multitude.convertFloor(int) 1 1 1 homework.tray.Multitude.getList() 1 1 1 homework.tray.Multitude.getMaxFloor() 1 1 1 homework.tray.Multitude.getMinDisFloor(int,int,int) 14 3 17 homework.tray.Multitude.getMinFloor() 1 1 1 homework.tray.Multitude.getMulInFloor(int) 1 1 1 homework.tray.Multitude.isEmpty() 3 2 3 homework.tray.Multitude.isEmptyFloor(int) 1 1 1 homework.tray.Multitude.removeMulInFloor(int) 1 1 1 homework.tray.Person.Person(PersonRequest) 1 1 1 homework.tray.Person.Person(int,int,int) 1 1 1 homework.tray.Person.clone() 1 1 1 homework.tray.Person.equals(Object) 2 1 2 homework.tray.Person.getFr() 1 1 1 homework.tray.Person.getTo() 1 1 1 homework.tray.Person.hashCode() 1 1 1 homework.tray.Person.makePersonIn() 1 1 1 homework.tray.Person.makePersonOut() 1 1 1 homework.tray.Person.moveUp() 1 1 1 homework.tray.Scheduler.Scheduler() 1 1 1 homework.tray.Scheduler.getMinDisFloor(int,int) 1 4 4 homework.tray.Scheduler.getOtherReq(int,int) 7 11 13 homework.tray.Scheduler.hasPassReqInFloor(int,int) 4 3 4 homework.tray.Scheduler.hasRequestInFloor(int) 1 1 1 homework.tray.Scheduler.makeMulIn(int) 1 2 2 homework.tray.Scheduler.minDistance(int,int,int,int) 2 1 2 homework.tray.Scheduler.readNewRequest(Person) 1 1 1 homework.tray.Scheduler.stopReading() 1 1 1 homework.tray.Scheduler.stopTask() 1 1 1 类复杂度上，ElevatorController飘红。 homework.MainClass 1 1 homework.custumer.Elevator 1.3 13 homework.custumer.Elevator.Status n/a 0 homework.custumer.ElevatorController 5.12 41 homework.producer.RequestParser 2 4 homework.tray.MulInside 1.67 5 homework.tray.MulOutside 1 2 homework.tray.Multitude 2.55 28 homework.tray.Multitude.Type n/a 0 homework.tray.Person 1.1 11 homework.tray.Scheduler 2.6 26 3.2 第六次作业▼ 基本结构图，MainClass启动输入线程和多个电梯线程，这次放弃了继承，并且优化了传递人员的方式，降低了耦合性。 ▼ 时序图。 ▼ 依赖关系，这次的架构是在第五次的基础上修改，也差不多。 Class Cyclic Dcy Dcy* Dpt Dpt* homework.MainClass 0 3 9 0 0 homework.custumer.Controller 0 2 7 1 1 homework.custumer.Elevator 0 3 3 1 3 homework.custumer.Elevator.Status 0 0 0 2 4 homework.custumer.ElevatorController 0 3 6 1 2 homework.custumer.ElevatorMul 0 1 1 1 4 homework.producer.RequestParser 0 2 3 1 1 homework.tray.Person 0 0 0 5 8 homework.tray.Scheduler 0 2 2 4 4 homework.tray.WaitMul 0 1 1 1 5 ▼ 复杂度，几个寻找最优解的方法都较为复杂，比如getBestOne中用了大量循环遍历比较获取最小值，基本复杂度和圈复杂度都比较差。 Method ev(G) iv(G) v(G) homework.MainClass.main(String[]) 1 1 1 homework.custumer.Controller.Controller(int,Scheduler) 1 1 1 homework.custumer.Controller.run() 1 2 2 homework.custumer.Elevator.Elevator(char) 1 1 1 homework.custumer.Elevator.close() 1 1 1 homework.custumer.Elevator.getCurrentFloor() 1 1 1 homework.custumer.Elevator.getMinDisReq(int,int) 1 1 1 homework.custumer.Elevator.getStatus() 1 1 1 homework.custumer.Elevator.isEmpty() 1 1 1 homework.custumer.Elevator.isFull() 1 1 1 homework.custumer.Elevator.move(boolean) 1 1 1 homework.custumer.Elevator.open() 1 1 1 homework.custumer.Elevator.putOne(Person) 1 1 1 homework.custumer.Elevator.setStatus(Status) 1 1 1 homework.custumer.Elevator.sleepTime(int) 1 1 2 homework.custumer.Elevator.updateCurrentFloor(boolean) 1 1 4 homework.custumer.ElevatorController.ElevatorController(Scheduler,char) 1 1 1 homework.custumer.ElevatorController.eleClose(int) 1 3 3 homework.custumer.ElevatorController.eleClosed(int,boolean) 1 5 6 homework.custumer.ElevatorController.eleWait(int,boolean) 2 4 4 homework.custumer.ElevatorController.getGoalFloor(int,boolean) 4 3 5 homework.custumer.ElevatorController.run() 2 4 11 homework.custumer.ElevatorMul.ElevatorMul() 1 2 2 homework.custumer.ElevatorMul.convertInFloor(int) 3 1 3 homework.custumer.ElevatorMul.convertOutFloor(int) 2 1 2 homework.custumer.ElevatorMul.getMinDisReq(int,int) 8 3 12 homework.custumer.ElevatorMul.isEleEmpty() 2 1 2 homework.custumer.ElevatorMul.isEleFull() 2 1 2 homework.custumer.ElevatorMul.mulOut(int) 1 2 2 homework.custumer.ElevatorMul.putOne(Person) 1 1 1 homework.custumer.ElevatorMul.updateEleSize(boolean) 1 1 2 homework.producer.RequestParser.RequestParser(Scheduler,ElevatorInput) 1 1 1 homework.producer.RequestParser.run() 3 3 4 homework.tray.Person.Person(PersonRequest) 1 1 1 homework.tray.Person.eleIdNull() 1 1 1 homework.tray.Person.equals(Object) 2 1 2 homework.tray.Person.getEl() 1 1 1 homework.tray.Person.getFr() 1 1 1 homework.tray.Person.getId() 1 1 1 homework.tray.Person.getMoveDis() 1 1 1 homework.tray.Person.getTo() 1 1 1 homework.tray.Person.getWaitDis() 1 1 1 homework.tray.Person.hashCode() 1 1 1 homework.tray.Person.makePersonIn() 1 1 1 homework.tray.Person.makePersonOut() 1 1 1 homework.tray.Person.moveUp() 1 1 1 homework.tray.Person.sameForward(boolean) 1 1 1 homework.tray.Person.setEl(char) 1 1 1 homework.tray.Person.setWaitDis(int) 1 1 1 homework.tray.Person.toString() 1 1 1 homework.tray.Scheduler.Scheduler() 1 1 1 homework.tray.Scheduler.failToGetOne(int,char) 1 1 1 homework.tray.Scheduler.getMinDis(int,int,char) 1 1 1 homework.tray.Scheduler.getMinDisWhenEmpty(int,char) 1 4 4 homework.tray.Scheduler.getOne(int,int,char) 1 1 1 homework.tray.Scheduler.hasRequestInFloor(int) 1 1 1 homework.tray.Scheduler.readNewRequest(Person) 1 1 1 homework.tray.Scheduler.stopReading() 1 1 1 homework.tray.Scheduler.stopTask() 1 1 1 homework.tray.Scheduler.updateFlag(int,char) 1 1 1 homework.tray.WaitMul.WaitMul() 1 2 2 homework.tray.WaitMul.addOutsideMul(Person) 1 1 1 homework.tray.WaitMul.convertInFloor(int) 3 1 3 homework.tray.WaitMul.convertOutFloor(int) 2 1 2 homework.tray.WaitMul.failToGetOne(int,char) 6 5 7 homework.tray.WaitMul.getBestOne(int,int,char) 1 1 1 homework.tray.WaitMul.getMinDisFloor(int,int,char) 8 3 12 homework.tray.WaitMul.hasRequestInFloor(int) 2 1 2 homework.tray.WaitMul.isEmpty() 3 2 3 homework.tray.WaitMul.searchBestOne(int,int,int,char) 4 7 9 homework.tray.WaitMul.updateFlag(int,char) 1 4 4 类复杂度上，这次的WaitMul设计由于放弃了继承关系，也不是很乐观。 Class OCavg WMC homework.MainClass 1 1 homework.custumer.Controller 1.5 3 homework.custumer.Elevator 1.23 16 homework.custumer.Elevator.Status n/a 0 homework.custumer.ElevatorController 4.17 25 homework.custumer.ElevatorMul 3 27 homework.producer.RequestParser 2 4 homework.tray.Person 1.06 18 homework.tray.Scheduler 1.1 11 homework.tray.WaitMul 3.91 43 3.3 第七次作业▼ 基本结构图，MainClass启动输入线程和电梯线程。 ▼ 时序图，这次加了SafeOutput的封装，虽然不加也没什么影响…… ▼ 依赖关系，同第六次作业。 Class Cyclic Dcy Dcy* Dpt Dpt* homework.MainClass 6 2 12 3 6 homework.SafeOutput 0 0 0 2 9 homework.custumer.Controller 6 2 12 1 6 homework.custumer.Elevator 6 6 12 1 6 homework.custumer.Elevator.EleTime 0 0 0 2 7 homework.custumer.Elevator.Status 0 0 0 2 7 homework.custumer.ElevatorController 6 6 12 1 6 homework.custumer.ElevatorMul 0 1 2 1 7 homework.producer.RequestParser 6 3 12 1 6 homework.tray.Person 0 1 1 6 8 homework.tray.Scheduler 6 2 12 4 6 homework.tray.WaitMul 6 3 12 1 6 ▼ 复杂度，问题和之前的都差不多。 Method ev(G) iv(G) v(G) homework.MainClass.main(String[]) 1 1 1 homework.SafeOutput.println(String) 1 1 1 homework.custumer.Controller.Controller(Scheduler) 1 1 1 homework.custumer.Controller.addElevator(ElevatorRequest) 1 1 1 homework.custumer.Controller.convertType(String) 3 2 3 homework.custumer.Controller.run() 1 1 1 homework.custumer.Elevator.Elevator(String,int) 1 1 1 homework.custumer.Elevator.close() 1 1 1 homework.custumer.Elevator.getCurrentFloor() 1 1 1 homework.custumer.Elevator.getMinDisReq(int,int) 1 1 1 homework.custumer.Elevator.getStatus() 1 1 1 homework.custumer.Elevator.inOne(Person) 1 3 3 homework.custumer.Elevator.isEmpty() 1 1 1 homework.custumer.Elevator.isFull() 1 1 1 homework.custumer.Elevator.move(boolean) 1 1 1 homework.custumer.Elevator.open() 1 3 3 homework.custumer.Elevator.outOne() 1 1 1 homework.custumer.Elevator.setStatus(Status) 1 1 1 homework.custumer.Elevator.sleepTime(EleTime) 2 2 5 homework.custumer.Elevator.updateCurrentFloor(boolean) 1 1 4 homework.custumer.ElevatorController.ElevatorController(Scheduler,String,int) 1 1 1 homework.custumer.ElevatorController.eleClose(int) 1 3 3 homework.custumer.ElevatorController.eleClosed(int,boolean) 1 5 6 homework.custumer.ElevatorController.eleOpen(int) 3 4 4 homework.custumer.ElevatorController.eleWait(int,boolean) 2 5 5 homework.custumer.ElevatorController.getGoalFloor(int,boolean) 4 3 5 homework.custumer.ElevatorController.run() 2 5 12 homework.custumer.ElevatorMul.ElevatorMul(int,int[]) 1 2 2 homework.custumer.ElevatorMul.convertIn(int) 3 1 3 homework.custumer.ElevatorMul.convertOut(int) 2 1 2 homework.custumer.ElevatorMul.getMinDisReq(int,int) 8 3 12 homework.custumer.ElevatorMul.inOne(Person) 1 1 1 homework.custumer.ElevatorMul.isEleEmpty() 2 1 2 homework.custumer.ElevatorMul.isEleFull() 2 1 2 homework.custumer.ElevatorMul.mulOut(int) 1 2 2 homework.custumer.ElevatorMul.outOne(int) 2 2 2 homework.custumer.ElevatorMul.updateEleSize(boolean) 1 1 2 homework.producer.RequestParser.RequestParser(Scheduler) 1 1 1 homework.producer.RequestParser.run() 3 5 6 homework.tray.Person.Person(PersonRequest) 1 1 1 homework.tray.Person.eleIdNull() 1 1 1 homework.tray.Person.equals(Object) 2 1 2 homework.tray.Person.getEl() 1 1 1 homework.tray.Person.getFr() 1 1 1 homework.tray.Person.getId() 1 1 1 homework.tray.Person.getMoveDis() 1 1 1 homework.tray.Person.getTo() 1 1 1 homework.tray.Person.getTransfer() 1 1 1 homework.tray.Person.getWaitTime() 1 1 1 homework.tray.Person.hashCode() 1 1 1 homework.tray.Person.makePersonIn() 1 1 1 homework.tray.Person.makePersonOut() 1 1 1 homework.tray.Person.moveUp() 1 1 1 homework.tray.Person.sameForward(boolean) 1 1 1 homework.tray.Person.setEl(String) 1 1 1 homework.tray.Person.setFr(int) 1 1 1 homework.tray.Person.setTransfer(int) 1 1 1 homework.tray.Person.setWaitTime(int) 1 1 1 homework.tray.Person.toString() 1 1 1 homework.tray.Person.transferPerson(int) 1 1 1 homework.tray.Scheduler.Scheduler() 1 1 1 homework.tray.Scheduler.failToGetOne(int,String,int) 1 1 1 homework.tray.Scheduler.getMinDis(int,int,String,int) 1 1 1 homework.tray.Scheduler.getMinDisWhenEmpty(int,String,int) 2 5 6 homework.tray.Scheduler.getOne(int,int,String,int) 1 1 1 homework.tray.Scheduler.hasRequestInFloor(int,String,int) 1 1 1 homework.tray.Scheduler.readNewRequest(Person) 1 1 1 homework.tray.Scheduler.stopReading() 1 1 1 homework.tray.Scheduler.stopTask() 1 1 1 homework.tray.Scheduler.tranOfTypeIsEmpty(int) 1 1 1 homework.tray.Scheduler.updateFlag(int,String,int) 1 1 1 homework.tray.WaitMul.WaitMul() 1 3 3 homework.tray.WaitMul.addOutsideMul(Person) 3 2 5 homework.tray.WaitMul.canStopIn(int,int) 1 1 1 homework.tray.WaitMul.convertIn(int) 3 1 3 homework.tray.WaitMul.convertOut(int) 2 1 2 homework.tray.WaitMul.failToGetOne(int,String,int) 3 1 3 homework.tray.WaitMul.getBestOne(int,int,String,int) 1 3 3 homework.tray.WaitMul.getDisOfTran(int,int,int) 1 1 1 homework.tray.WaitMul.getEleType(int) 3 1 3 homework.tray.WaitMul.getInsideTransfer(int,int) 4 4 14 homework.tray.WaitMul.getInsideTransfer(int,int,int,int) 2 3 4 homework.tray.WaitMul.getMinDisFloor(int,int,String,int) 2 4 4 homework.tray.WaitMul.getMinDisPerson(int,int,String,int) 4 2 8 homework.tray.WaitMul.getMinDownFloorReq(int,int,String,int) 3 2 3 homework.tray.WaitMul.getMinUpFloorReq(int,int,String,int) 3 2 3 homework.tray.WaitMul.getTranOfType(int) 3 2 3 homework.tray.WaitMul.hasRequestInFloor(int,int,String,int) 2 1 2 homework.tray.WaitMul.isEmpty() 3 2 3 homework.tray.WaitMul.mustTakeIn(int,int) 1 1 1 homework.tray.WaitMul.removeOneInTran(int) 1 3 3 homework.tray.WaitMul.searchInFloor(int,int,int,String,int) 6 7 12 homework.tray.WaitMul.tranOfTypeIsEmpty(int) 1 2 2 homework.tray.WaitMul.tranPut(int,int,int) 1 4 4 homework.tray.WaitMul.tranWait(int,int) 2 1 3 homework.tray.WaitMul.updateFlag(int,String,int) 1 4 4 类复杂度也一样。 Class OCavg WMC homework.MainClass 1 1 homework.SafeOutput 1 1 homework.custumer.Controller 1.5 6 homework.custumer.Elevator 1.57 22 homework.custumer.Elevator.EleTime n/a 0 homework.custumer.Elevator.Status n/a 0 homework.custumer.ElevatorController 4.29 30 homework.custumer.ElevatorMul 2.9 29 homework.producer.RequestParser 3 6 homework.tray.Person 1.05 22 homework.tray.Scheduler 1.18 13 homework.tray.WaitMul 3.24 81 四、三省吾身4.1 第五次作业本次作业在强测中没有出现Bug，在互测中没有被Hack。 4.2 第六次作业本次作业在强测中没有出现Bug，在互测中没有被Hack。 4.3 第七次作业本次作业在强测中没有出现Bug，在互测中被Hack一次。 这次很惨地被Rider暴捶，Rider实在是一个居住在OO网站上的狠人，最终战绩30 / 168，从头到尾穷追不舍Berserker，hack了我试了好几次也打不到的Alterego（我本地会测出他有死锁的情况），用运行超时死锁虐了我和Saber…… Rider从头到尾就在提交一个数据（除了固定欺负Berserker，还会捎带暴捶我们）： [1.0]651-FROM-5-TO-15[1.0]404-FROM-9-TO-1[5.0]797-FROM-10-TO-1[5.0]75-FROM-2-TO--2[5.0]816-FROM-1-TO-7[5.0]699-FROM-9-TO--3[9.0]46-FROM-11-TO-2[9.0]592-FROM--3-TO--2[9.0]152-FROM-1-TO--3[9.0]480-FROM-1-TO-2[9.0]385-FROM--3-TO-6[9.0]199-FROM--3-TO-1[9.0]632-FROM-13-TO-20[9.0]562-FROM-6-TO-12[9.0]72-FROM-9-TO-4[13.0]995-FROM-1-TO--2[13.0]977-FROM-1-TO-12[13.0]633-FROM-1-TO-3[13.0]176-FROM-1-TO-11[13.0]865-FROM-2-TO-1[13.0]471-FROM-8-TO-1[13.0]594-FROM-11-TO-4[13.0]765-FROM-3-TO--3[13.0]478-FROM-1-TO--3[17.0]357-FROM-1-TO-11[17.0]604-FROM-9-TO-8[17.0]447-FROM-1-TO-10[17.0]106-FROM-9-TO-14[17.0]194-FROM-7-TO-1[17.0]387-FROM-12-TO-1[17.0]760-FROM-1-TO-14[17.0]X1-ADD-ELEVATOR-C[17.0]874-FROM-16-TO--3[17.0]369-FROM-1-TO-9[17.0]268-FROM-8-TO--3[17.0]498-FROM--3-TO-5[17.0]340-FROM-10-TO-4[17.0]859-FROM-1-TO-8[17.0]423-FROM-1-TO-14[17.0]211-FROM--1-TO-2[21.0]518-FROM-17-TO-14[21.0]242-FROM-10-TO-1[25.0]871-FROM--3-TO-6[25.0]427-FROM--1-TO-1[25.0]X2-ADD-ELEVATOR-A[29.0]975-FROM-14-TO-1[29.0]504-FROM-1-TO--1[29.0]942-FROM-1-TO--1[29.0]96-FROM-1-TO--1[29.0]133-FROM--3-TO-1[29.0]558-FROM-15-TO--3[29.0]X3-ADD-ELEVATOR-A 单看数据，这组数据的特点是分几个时间段，在同一时刻进行大量乘客投放和电梯增加操作。 那么为什么会发生死锁呢？相信我们房间的同学都很想了解为什么会发生死锁，小编对于会发生死锁这件事也感到很惊讶，但是就是发生死锁了，那么这就是发生死锁的故事了。对于这件事情大家有什么看法呢，欢迎在评论区留言哦。 ……言归正传……我本地将这个数据跑了1000次，也没有成功复现。而根据课程组提供的加密输出，可以发现产生死锁的样例输出中间有明显间隔期，然而CPU时间为1.2s，说明没有发生暴力轮询，而我所采用的架构是人类在每次电梯发生楼层改变时都会重新呼叫当前最近的电梯，所以……我是真的想不出来原因了……解决办法就是给wait价格时间限制试试？但我也不清楚这个的作用，毕竟直接再交一遍也过了…… 以上，互测被扣分了是我能力不够，等解禁了一定要加Rider膜拜一下，对于这个问题我也不会忘记的，以后姿势水平提升了要努力弄明白。 五、互测策略第五、六次没有发现他人Bug，但是第六次有房间成员发现他人Bug……第七次发现3处Bug，Hack成功2处。 在互测时发现了别人的线程不安全Bug： 调度器类使用for each遍历当前电梯列表，如果这时出现新的电梯添加请求（迭代过程中进行了修改），就会抛异常。（提交4次数据成功1次） 而互测策略上，这次就没有对拍……多线程主要依赖自动测试，感谢HDL学长的定时输入轮子和某位学长的自动化测试机和WPB的多线程评测机。这里再次膜拜一下一个样例提交20多次的居住在OO网站上的Rider。 一些卡时间点的数据我试了下无人中招……毕竟对自己的性能有一点自信，所以当时互测就没有深入测试……这里再次膜拜一下卡RTLE的居住在OO网站上的Rider。 六、心得体会从难度上来说，我觉得第二单元比第一单元略小。第一单元为了性能和正确性，需要考虑的东西还挺多的。而虽然说相比去年今年第二单元的进度提早、需求增加，但是有了第一单元学习到的经验，迭代开发使得三次作业的改进更加方便。 这一单元关于锁的概念理解与实际操作非常重要，我主要使用synchronized关键字修饰单一类的方法，发生死锁的概率较低。而多线程也对自动化测试有了更高的要求，之后也要强化Python编程能力。 不过这三次还是花了很多时间在修复Bug上，希望下次可以避免。","permalink":"https://mondaycha.github.io/2020/04/09/414-1/","photos":[]},{"tags":[{"name":"推送","slug":"推送","permalink":"https://mondaycha.github.io/tags/%E6%8E%A8%E9%80%81/"}],"categories":[{"name":"写作","slug":"写作","permalink":"https://mondaycha.github.io/categories/%E5%86%99%E4%BD%9C/"}],"title":"学到深夜的你，可还有捧起一本书的时间？","date":"2020/04/08","text":"学到深夜的你，可还有捧起一本书的时间？一份不科学不严谨的思维逻辑类书单推荐 不知是从何时起，留给我们读书的时间似乎越来越少。 这篇推文里，为你节选了豆瓣的5本高分思维逻辑类书籍。 如果感兴趣，那就放下手机去看看吧。 如何阅读一本书作者: [美] 莫提默·艾德勒/ 查尔斯·范多伦 原作名: How to Read a Book 豆瓣评分：8.4 每本书的封面之下都有一套自己的骨架，作为一个分析阅读的读者，责任就是要找出这个骨架。一本书出现在面前时，肌肉包着骨头，衣服包裹着肌肉，可说是盛装而来。读者用不着揭开它的外衣或是撕去它的肌肉来得到在柔软表皮下的那套骨架，但是一定要用一双X光般的透视眼来看这本书，因为那是了解一本书、掌握其骨架的基础。 批判性思维作者: [美]布鲁克.诺埃尔.摩尔) / [美]理查德.帕克副标题: 带你走出思维的误区原作名: Critical Thinking 豆瓣评分：8.4 这本书也是美国最为畅销的大学教材，连续九次再版，语言通俗、生动，直观地阐述了批判性思维、正确推理和合理论证的基本问题、观点、方法和技巧。《批判性思维：带你走出思维的误区》从批判性思维的重要性和必要性说起，就如何进行正确地思维和清晰地写作，到有效论证的规则、合理的演绎和归纳推理，再到道德、法律和美学的论证进行了详细阐述，同时还指出了各种以修辞手法来掩盖虚假论证的例子，对批判性思维进行了全面的论述，帮助读者全面了解和掌握合理而正确的思维基本原则、规则、要求、技巧和训练方法。 经济学的思维方式作者: 托马斯·索维尔原作名: Basic Economics : A Common Sense Guide to the Economy 豆瓣评分：8.3 经济学一点也不复杂，也不难理解，困扰我们的是故作艰深的语言和拒人千里之外的形式。本书没有让人望而生畏公式图表，也没有难懂的术语，更没有枯燥的实证。托马斯·索维尔用最贴近日常生活的语言和案例，为我们讲解经济学博士都不一定能完全掌握的经济学思维方式，让所有人都能体验毫无障碍的阅读，并且在无形中学会经济学这一门专业知识体系和分析工具，让普通人不再受含糊的政治辞令和晦涩的经济学术语的迷惑，掌握经济社会的运转规律。 自控力作者: [美] 凯利·麦格尼格尔 / [美] 凯利·麦格尼格尔副标题: 斯坦福大学最受欢迎心理学课程原作名: The Willpower Instinct:How Self-control Works,Why it Matters,and What You Can do to Get More of It 豆瓣评分：8.2 “这本书不会教给你什么捷径，但能告诉你一种快速提高意志力的方法：将呼吸频率降低到每分钟46次，也就是每次呼吸用1015秒时间，比平常呼吸要慢一些。只要你有足够的耐心，加上必要的练习，这一点不难办到。”《自控力》一书为读者提供了清晰的框架，讲述了什么是自控力，自控力如何发生作用，以及为何自控力如此重要。 逻辑思维简易入门作者: （美）加里•西伊（Gary Seay） / 苏珊娜•努切泰利（Susana Nuccetelli）译者: 廖备水 / 雷丽赟 / 冯立荣 豆瓣评分：7.1 本书是一本逻辑思维和批判性思维的入门读物，涉及主题十分广泛，专为并未接触过哲学或逻辑思维的读者而设计，行文简易、直接，专业术语数量降至最少，符号也较简单，兼具可读性、严谨性和准确性。","permalink":"https://mondaycha.github.io/2020/04/08/408-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab2 实验报告","date":"2020/04/04","text":"OS Lab2 实验报告感谢PB，PB大救星。 一、实验思考题Thinking 2.1请思考cache用虚拟地址来查询的可能性，并且给出这种方式对访存带来的好处和坏处。另外，你能否能根据前一个问题的解答来得出用物理地址来查询的优势? 答： 如果使用虚拟地址来查询cache： 好处：当TLB未命中，cache命中时，可以直接用虚拟地址查询，不需要经过MMU的转换。 坏处：一个物理地址可映射到多个虚拟地址，多进程共用cache可能会造成数据访问错误，最终还是需要通过物理地址校验是否命中。 用物理地址来查询的优势： 用物理地址查询，物理地址命中则必命中。 Thinking 2.2请查阅相关资料，针对我们提出的疑问，给出一个上述流程的优化版本，新的版本需要有更快的访存效率。（提示：考虑并行执行某些步骤） 答： 优化版本： CPU给出虚拟地址来访问数据，TLB接收到这个地址之后查找是否有对应的页表项。 假设页表项存在，则根据物理地址在cache中查询；如果不存在，则MMU执行正常的页表查询工作之后再根据物理地址在cache中查询，同时更新TLB中的内容。 如果cache命中，则直接返回给CPU数据；如果没有命中则按照相应的算法进行cache的替换或者装填，同时并行返回给CPU数据。 Thinking 2.3在我们的实验中，有许多对虚拟地址或者物理地址操作的宏函数(详见include/mmu.h ),那么我们在调用这些宏的时候需要弄清楚需要操作的地址是物理地址还是虚拟地址，阅读下面的代码，指出x是一个物理地址还是虚拟地址。 int x;char *value = return_a_pointer();*value = 10;x = (int) value; 答： x是虚拟地址。 Thinking 2.4我们在 include/queue.h 中定义了一系列的宏函数来简化对链表的操作。实际上，我们在 include/queue.h 文件中定义的链表和 glibc 相关源码较为相似，这一链表设计也应用于 Linux 系统中 (sys/queue.h 文件)。请阅读这些宏函数的代码，说说它们的原理和巧妙之处。 答： 原理：通过宏定义的形式描述双向链表。 巧妙之处： 不依赖具体的类型，由宏定义的传参决定。 采用特殊的双重链表结构，好处是删除方便。比如在Page结构体中，pp_link有两个域，其中le_next指向下一个页结构体，le_prev指向上一个页结构体的pp_link的le_next。这样在进行删除的时候主要知道需要删除的节点就可以了。 Thinking 2.5我们注意到我们把宏函数的函数体写成了 do { /* ... */ } while(0)的形式，而不是仅仅写成形如 { /* ... */ } 的语句块，这样的写法好处是什么？ 答： 辅助定义复杂的宏，避免在进行引用时出错，使宏在展开后保留语义。 Thinking 2.6注意，我们定义的 Page 结构体只是一个信息的载体，它只代表了相应物理内存页的信息，它本身并不是物理内存页。 那我们的物理内存页究竟在哪呢？Page 结构体又是通过怎样的方式找到它代表的物理内存页的地址呢？ 请你阅读 include/pmap.h 与 mm/pmap.c 中相关代码，给出你的想法。 答： 物理内存页在设备的物理内存中，Page 结构体由alloc初始化入口，根据Page 结构体指针，通过page2pa，减去起始位找到它的页号，乘以页面大小，得到其代表的物理内存页的地址。 Thinking 2.7请阅读 include/queue.h 以及 include/pmap.h, 将Page_list的结构梳理清楚,选择正确的展开结构(请注意指针)。 答： C: struct Page_list{ struct { struct { struct Page *le_next; struct Page **le_prev; } pp_link; u_short pp_ref; }* lh_first;} Thinking 2.8在 mmu.h 中定义了 bzero(void *b, size_t) 这样一个函数,请你思考，此处的b指针是一个物理地址， 还是一个虚拟地址呢？ 答： 虚拟地址。 Thinking 2.9了解了二级页表页目录自映射的原理之后，我们知道，Win2k内核的虚存管理也是采用了二级页表的形式，其页表所占的 4M 空间对应的虚存起始地址为 0xC0000000，那么，它的页目录的起始地址是多少呢？ 答： 0xC0030000 计算方式：0xC0000000 + (0xC0000000 >> 12) * 4 = 0xC0030000。 Thinking 2.10注意到页表在进程地址空间中连续存放，并线性映射到整个地址空间，思考：是否可以由虚拟地址直接得到对应页表项的虚拟地址？上一节末尾所述转换过程中，第一步查页目录有必要吗，为什么？ 答： 由页表与虚拟地址空间的映射关系，可以根据虚拟地址得到对应页表项的虚拟地址。 有必要。第一步查页目录获取的时二级页表的物理地址。 Thinking 2.11思考一下tlb_out 汇编函数，结合代码阐述一下跳转到NOFOUND的流程？从MIPS手册中查找tlbp和tlbwi指令，明确其用途，并解释为何第10行处指令后有4条nop指令。 答： 跳转到NOFOUND的流程： 保存CP0_ENTRYHI的值，刷新CP0_ENTRYHI，查询TLB表项，如无效跳转到NOFOUND，并恢复CP0_ENTRYHI的值；若有效，valid写入0，跳转到NOFOUND，并恢复CP0_ENTRYHI的值。 指令： Format: TLBP MIPS32Purpose: To find a matching entry in the TLB. Format: TLBWI MIPS32Purpose: To write a TLB entry indexed by the Index register. TLBP用于查找TLB，TLBWI用于向TLB指定位置写入。 4条nop指令： 清空流水线，防止异常出现影响CP0工作。 Thinking 2.12显然，运行后结果与我们预期的不符，va值为0x88888，相应的pa中的值为0。这说明我们的代码中存在问题，请你仔细思考我们的访存模型，指出问题所在。 答： 在代码中使用了va2pa函数，返回的是页的起始地址，转换过程中清空了低12位，因此获取的pa并不是0x88888对应的值。 Thinking 2.13在X86体系结构下的操作系统，有一个特殊的寄存器CR4，在其中有一个PSE位，当该位设为1时将开启4MB大物理页面模式，请查阅相关资料，说明当PSE开启时的页表组织形式与我们当前的页表组织形式的区别。 答： 目前是二级页表组织形式，开启4MB大物理页面模式后是一个一级页表表项直接映射到4MB大小的页。在Xv6系统初始化时，会使用到4MB大页。 Thinking 2.11（指导书）观察给出的代码可以发现，page_insert 会默认为页面设置PTE_V的权限。请问，你认为是否应该将PTE_R 也作为默认权限？并说明理由。 答： 不应该，PTE_R为写权限位，而在进行page_insert时并不知道页面是否可写。 二、实验难点图示实验中比较难的地方，一个是这里的地址转换： 另外一个地方就是双重链表的操作，这边的链表操作函数实在是绕……比如LIST_INSERT_BEFORE函数： /* * Insert the element \"elm\" *before* the element \"listelm\" which is * already in the list. The \"field\" name is the link element * as above. */#define LIST_INSERT_BEFORE(listelm, elm, field) do { \\ (elm)->field.le_prev = (listelm)->field.le_prev; \\ LIST_NEXT((elm), field) = (listelm); \\ *(listelm)->field.le_prev = (elm); \\ (listelm)->field.le_prev = &LIST_NEXT((elm), field); \\ } while (0) 这里的9是*((listelm)->field.le_prev)，也就是listelm的上一个preelm的next指向插入的elm；10则是让listelm的prev指针指向elm的next指针，从而实现链表的前插操作。 再次祭出这张群友发的图（现在想想数据结构是大一下，彼时是大二下的助教们大概率就是从OS课上获得的灵感）： 所以LIST_REMOVE函数就是这么写的： /* * Remove the element \"elm\" from the list. * The \"field\" name is the link element as above. */#define LIST_REMOVE(elm, field) do { \\ if (LIST_NEXT((elm), field) != NULL) \\ LIST_NEXT((elm), field)->field.le_prev = \\ (elm)->field.le_prev; \\ *(elm)->field.le_prev = LIST_NEXT((elm), fieldc); \\ } while (0) 要从链表中删除elm，那么就先把elm的下一个元素的prev指针设置为elm的前一个元素的next，再将elm的上一个preelm的next指向后一个elm。删除这个元素只需知道其自身。 最后是思维导图式的难点树—— ![](G:\\OneDrive\\OneDrive - buaa.edu.cn\\MWD\\学习\\操作系统\\作业\\Refer\\内存管理难点.png) 三、体会与感想Lab2难度评价：★★★★☆ Lab2-extra难度评价：★★★☆☆ 花费时间：Lab2 15h，Lab2-extra 4h 体会和感想： 第二次Lab我也写了很久，总结发在了自己的暂定·博客里——https://mondaycha.github.io/2020/03/29/329-1/。 这也是一次很有挑战性的Lab，分值也很高。感谢学长的资料以及群里的讨论，让我学到了很多。OS对自学的要求很高，之后也要继续加油。","permalink":"https://mondaycha.github.io/2020/04/04/404-1/","photos":[]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"},{"name":"影评","slug":"影评","permalink":"https://mondaycha.github.io/tags/%E5%BD%B1%E8%AF%84/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"就对映像研出手~","date":"2020/04/03","text":"前附：希望这个影评能坚持下去…… 2020.04.14 哈哈哈哈哈果然咕了","permalink":"https://mondaycha.github.io/2020/04/03/403-1/","photos":["http://zkres1.myzaker.com/202001/5e29ac0a8e9f092eac5e7511_1024.jpg"]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week5","date":"2020/04/02","text":"爱课程 2.3 飞机的阻力在这节课我学习到，由于流程之间有内摩擦，在靠近管壁的时候流速慢一点。空气和空气之间的流程会产生摩擦，空气与飞行器的表面也会产生摩擦。空气的粘性低表面光滑度，气流流动状态，体表面积大小都是粘性摩擦阻力的影响因素。相同的迎风截面积条件下，不同形状和尺寸的物体上有相同的阻力。 爱课程 3.1 超声速飞行特点在这节课我学习到，超声速飞机的多种翼型，尽可能兼顾高速飞行与低速飞行之间的矛盾。国产歼十使用的是鸭式翼。超声速飞行还会产生声爆和热障，对周围环境和飞机的飞行都有着比较大的影响。超声速飞行器比低亚声速飞行器有了很大的外形区别。 为什么飞机设计时要尽量增大升力？如同奥运精神是更高更快更强，飞行器也在追求更高更快更远更安全更舒适。在飞机设计时要尽量增大升力，因为这样就可以承载更大的重量。更加符合人们对航空运输的飞行器实际应用的需求。 为什么飞机设计时要尽量减小阻力？影响飞机飞行的因素主要是升力和阻力，通过减小阻力在进行飞行的过程中就可以采用更小的发动机功率，更加经济。另外阻力较大时也会产生粘性摩擦等，对飞机的制造材料也有了更高的要求，所以尽量减小阻力有利于飞机的安全稳定性。","permalink":"https://mondaycha.github.io/2020/04/02/402-1/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://mondaycha.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"Shields 测试","date":"2020/03/31","text":"这是测试页，如果正常，下方有图片—— 感谢YLS给我的Bilibili粉丝做的小牌牌","permalink":"https://mondaycha.github.io/2020/03/31/331-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://mondaycha.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab2 学习笔记 (Part 2)","date":"2020/03/29","text":"OS Lab2的难度还是比较大的，为了更好的掌握，我希望能通过撰写博客加深对相关知识点的理解。 学习时的参考资料在学习Lab2的过程中，最正经的方式应该是认真阅读所有相关的代码与宏……不过发现了两名学长的博客，对于Lab2的介绍很充分—— LAB2初始化流程的梳理：https://ausar.xyz/index.php/archives/66/#comments 操作系统lab2实验总结——Part1：https://www.cnblogs.com/puublog/p/10657916.html 希望能边写边理清思路……要不然课上测试biss…… MMU/TLB和内存访问Lab2的内容主要与内存管理有关。内存翻译中的两大部件：MMU和TLB，其中MMU是硬件设备，将逻辑地址映射为物理地址，并可以实现内存访问的权限检查。TLB则是为了解决多级页表带来的访存低效的问题，是页表的一部分高速缓存，让计算机能够不经过页表就把虚拟地址映射成物理地址。 而关于Cache，这部分我其实还不是特别理解，在做思考题的时候再想清楚。 MIPS虚拟映射布局32位的MIPS CPU最大寻址空间为4GB(2^32字节)，被划分为4部分—— kuseg，2G，用户内存空间，需要通过MMU进行虚拟地址到物理地址的转换。 kseg0，512M，内核地址，将最高位清零就可以被转换为物理地址，使用缓存。 kseg1，512M，内核地址，高三位清零可转换，不使用缓存，通常用来实现对外设的访问。 kseg2，1G，只能在内核态使用，需要MMU的转换。 其他小Point: 内核态上述虚存空间都可以访问 kuseg、kseg2访问需要通过MMU 物理内存管理初始化流程说明在Lab2，内核加载完毕后跳转到init/main.c下执行程序， main.c内部调用了mips_init();，这是一个死循环函数，如果停止则会通过panic报错。那么panic是啥呢？在include/printf.h下可以找到定义： #define panic(...) _panic(__FILE__, __LINE__, __VA_ARGS__) 具体查看include/printf.c，发现在打印错误信息之后就陷入死循环等待中断处理。 mips_init();通过mips_detect_memory();，mips_vm_init();，page_init();三个函数来实现物理内存管理的相关数据结构的初始化。 内存控制块4KB为一页，内存分配也是以页为基本单位进行。为了记录分配情况，课程中使用Page结构体保存一页内存相关信息，定义在include/pamp.h中： typedef LIST_ENTRY(Page) Page_LIST_entry_t;struct Page { Page_LIST_entry_t pp_link; /* free list link */ // Ref is the count of pointers (usually in page table entries) // to this page. This only holds for pages allocated using // page_alloc. Pages allocated at boot time using pmap.c's \"alloc\" // do not have valid reference count fields. u_short pp_ref;}; pp_link的类型为LIST_ENTRY(Page)，其定义可以在include/queue.h中找到： /* * Use this inside a structure \"LIST_ENTRY(type) field\" to use * x as the list piece. * * The le_prev points at the pointer to the structure containing * this very LIST_ENTRY, so that if we want to remove this list entry, * we can do *le_prev = le_next to update the structure pointing at us. */#define LIST_ENTRY(type) \\ struct { \\ struct type *le_next; /* next element */ \\ struct type **le_prev; /* address of previous next element */ \\ } 这就是在上次的总结中提过的特殊的双重链表结构，好处是删除方便。所以在Page结构体中，pp_link有两个域，其中le_next指向下一个页结构体，le_prev指向上一个页结构体的pp_link的le_next。(listelm)->field.le_prev是listelm上一个elm的le_next，让它指向新增的elm。关于这一点可以在include/queue.h中的LIST_INSERT_AFTER定义中找到： (elm)->field.le_prev = &((listelm)->field.le_next); pp_ref则是这一页面的引用次数。所以Page结构体大概就是一张存储页使用信息、地址的链表，本身并不是物理内存页。之后的exercise2.1就是关于链表操作函数LIST_INSERT_HEAD和LIST_INSERT_TAIL的补全。单从插入效率的角度LIST_INSERT_HEAD函数显然更好一些，后者还要遍历链表。 这边的链表操作函数实在是绕……比如LIST_INSERT_BEFORE函数： /* * Insert the element \"elm\" *before* the element \"listelm\" which is * already in the list. The \"field\" name is the link element * as above. */#define LIST_INSERT_BEFORE(listelm, elm, field) do { \\ (elm)->field.le_prev = (listelm)->field.le_prev; \\ LIST_NEXT((elm), field) = (listelm); \\ *(listelm)->field.le_prev = (elm); \\ (listelm)->field.le_prev = &LIST_NEXT((elm), field); \\ } while (0) 这里的9是*((listelm)->field.le_prev)，也就是listelm的上一个preelm的next指向插入的elm；10则是让listelm的prev指针指向elm的next指针，从而实现链表的前插操作。 再次祭出这张群友发的图（现在想想数据结构是大一下，彼时是大二下的助教们大概率就是从OS课上获得的灵感）： 所以LIST_REMOVE函数就是这么写的： /* * Remove the element \"elm\" from the list. * The \"field\" name is the link element as above. */#define LIST_REMOVE(elm, field) do { \\ if (LIST_NEXT((elm), field) != NULL) \\ LIST_NEXT((elm), field)->field.le_prev = \\ (elm)->field.le_prev; \\ *(elm)->field.le_prev = LIST_NEXT((elm), fieldc); \\ } while (0) 要从链表中删除elm，那么就先把elm的下一个元素的prev指针设置为elm的前一个元素的next，再将elm的上一个preelm的next指向后一个elm。删除这个元素只需知道其自身。 内存分配和释放在exercise2.2需要补全mips_detect_memory()函数，这是我们init的第一步。这里需要让操作系统知道可用的物理内存的大小和范围，也就是对提示的四个全局变量进行设置。根据输出判断extra为0，gxemul模拟内核运行环境的时候并没有模拟插外置存储的情况。 之后在mips_vm_init()中完成了对操作系统内核所必须的数据结构 – 页目录（pgdir）、内存控制块数组（pages）和进程控制块数组（envs）所需的物理内存的分配，这一部分会在最后的启动流程中再梳理一遍。在完成对这几个关键部分的内存分配之后，剩余的内存就可以加入到空闲链表中，这一步需要用到page_init()函数，也就是exercise2.3的实验内容。 在page_init()函数的注释突然出现了一个全局变量——freemem，那么它是啥呢？它的类型是物理地址、虚拟地址还是内核虚拟地址？C语言中long的全局变量初值为0，在mips_vm_init()中调用了alloc函数，就涉及对freemem的赋值，这里用到了extern指向的end[]数组来赋初值，但我没有在文件中找到最开始的定义……奇了怪了；而从这里用到的PADDR(kva)宏也可以得出freemem是内核虚拟地址的结论，这一点在我们后续的操作中十分重要。 总之由于内存的分配是连续的，所以freemem之前指向的就是已经分配完毕的页，应该要将其pp_ref置1，之后则是未分配的，将其pp_ref置0并加入到空闲页的链表中，由此就可以进行以页为单位的物理内存分配与释放。 在exercise2.4里，page_alloc函数用来从空闲链表中分配一页物理内存，而page_free函数则用于将一页之前分配的内存重新加入到空闲链表中。 虚拟内存管理地址转换 内核虚拟地址：0x80010000，kseg0 PADDR(kva)：虚拟地址到物理地址的转换 KADDR(pa)：物理地址到虚拟地址的转换 PDX(va)：获得一个虚拟地址对应的页目录索引 PTX(va)：获得这个虚存地址对应的页表索引 页目录自映射 进程的页表位置：UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间，4MB 创建页表在exercise2.5，需要对mm/pmap.c中的boot_pgdir_walk和pgdir_walk函数进行填充，其中boot_pgdir_walk是在内核刚启动的时候运行，通过alloc直接以字节为单位分配物理内存；后者在空闲页面链表初始化之后运行，使用page_alloc以页为单位分配物理内存。 首先来看看boot_pgdir_walk： /* Overview: Get the page table entry for virtual address `va` in the given page directory `pgdir`. If the page table is not exist and the parameter `create` is set to 1, then create it.*/static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create){ Pde *pgdir_entryp; Pte *pgtable, *pgtable_entry; /* Step 1: Get the corresponding page directory entry and page table. */ /* Hint: Use KADDR and PTE_ADDR to get the page table from page directory * entry value. */ pgdir_entryp = pgdir + PDX(va); // 通过 PDX(va) 来获得一个虚拟地址对应的页目录索引 // 凭借索引在页目录中得到对应的二级页表的基址(物理地址) if ((*pgdir_entryp) && PTE_V) // 检测地址是否有效 { pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp)); // 把这个物理地址转化为内核虚拟地址(KADDR) } /* Step 2: If the corresponding page table is not exist and parameter `create` * is set, create one. And set the correct permission bits for this new page * table. */ // 如果虚拟地址所对应的二级页表不存在 else if (create == 1) // 为这个虚拟地址创建一个新的页表 { pgtable = (Pte *)alloc(BY2PG, BY2PG, 1); // 申请一页物理内存来存放这个页表 // 将它的物理地址赋值给对应的页目录项 *pgdir_entryp = PADDR(pgtable) | PTE_V; // 设置好页目录项的权限位 } /* Step 3: Get the page table entry for `va`, and return it. */ pgtable_entry = &pgtable[PTX(va)]; // 通过 PTX(va) 获得这个虚存地址对应的页表索引 return pgtable_entry; // 从页表中得到对应的页面的物理地址} 返回值是Pte，输入值则包括Pde的指针，这两者的定义在include/mmu.h中可以找到： typedef u_long Pde;typedef u_long Pte; 两者都是unsigned long类型，长度为32位，而虚拟地址的长度也是32位，方便转换。 这里理解还不够深入，援引学长的解释： 下面说明一下Pde*的理解（Pde*和Pte*是一样的） Pde *pgdir_entryp; 在include/mmu.h中定义了 typedef` `u_long Pde; Pde的类型就是unsigned long，占4B。它的指针是要寻找虚拟空间，大小也是一个页表项，4B。Pde和Pde*都是4B，使它们的转换非常方便。指针实际上一块以它为地址的内存单元。所以Pde的指针(Pde*)所指的地址就是虚拟地址，而这块地址的内容(Pde)是物理地址，所以实现了虚拟地址和物理地址的映射关系。 而pgdir_walk函数也与之类似，区别在于创建时的处理： else if (create == 1) { if (page_alloc(&ppage) == -E_NO_MEM) // out of memory. { return -E_NO_MEM; } // 已经申请好了页，传入的指针已经改变 pgtable = page2kva(ppage); *pgdir_entryp = PADDR(pgtable) | PTE_R | PTE_V; // PTE_R：脏位 ppage->pp_ref++; // 这个设置ref的操作不要忘了…… } 地址映射将相应的物理页面地址填入对应虚拟地址的页表项，填充mm/pmap.c中的boot_map_segment函数。 在exercise2.6，将[va, va+size)的虚拟地址映射到物理地址[pa,pa+size)中，根据perm对这个地址标记位更新，实现了在虚拟地址所对应的二级页表里存放（物理页框的）物理地址。 通过for循环实现，函数内还给了临时变量。 /* Step 2: Map virtual address space to physical address. *//* Hint: Use `boot_pgdir_walk` to get the page table * entry of virtual address `va`. */for (i = 0; i < (size / BY2PG); i++)// 这里回头记得修改，感觉Pb说的很有道理……{ va_temp = va + i * BY2PG; // 突然发现这里可以用更好的方式…… pgtable_entry = boot_pgdir_walk(pgdir, va_temp, 1); // 返回页表项的虚拟地址 *pgtable_entry = (pa + i * BY2PG) | perm | PTE_V; // 指向物理地址，设置标记位} 这个函数完成了对于[va,va+size)这一片虚拟地址的页表的设置，把对应的物理地址存入了对应的页表中。 page insert and page remove在exercise2.7，需要填充page_insert函数，该函数将va虚拟地址和其要对应的物理页pp的映射关系以perm的权限设置加入页目录。 int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm); 然后就是复习汇编知识……想到我的78分祭祖理论课瑟瑟发抖……从MIPS手册中查找tlbp和tlbwi指令。 Format: TLBP MIPS32Purpose: To find a matching entry in the TLB. Format: TLBWI MIPS32Purpose: To write a TLB entry indexed by the Index register. 最后的最后啊，真的好多…… 写到这里脑子确实清楚了一些，明天写Extra吧。 加油！奥里给！","permalink":"https://mondaycha.github.io/2020/03/29/329-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS 第五次作业","date":"2020/03/25","text":"1）叙述缺页中断的处理流程。 现场保护：陷入内核态，保存必要的信息。 页面定位：查找出发生缺页中断的虚拟页面。 权限检查：检查虚拟地址的有效性以及安全保护位，如果发生保护错误，则杀死该进程。 分配页框：查找一个空闲的页框；如果没有则通过页面置换算法找到一个需要换出的页框。 页面写回：如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。 页面调入：将保持在磁盘上的页面内容复制到该页框中。 更新页表：当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。 恢复现场：恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。 继续执行：退出内核态，程序重新执行引发缺页中断的指令，进行存储访问。 2）假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：(1) LRU、FIFO和Clock算法的效果如何？(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？ LRU、FIFO和Clock算法的效果均相同。 算法：尽可能减少替换的页面。将其中499页框用于固定页面的映射，剩下1个页面可替换。 3）假设有10个页面，n个页框。页面的访问顺序为0, 9, 8, 4, 4, 3, 6, 5, 1, 5, 0, 2, 1, 1, 1, 1, 8, 8, 5, 3, 9, 8, 9, 9, 6, 1, 8, 4, 6, 4, 3, 7, 1, 3, 2, 9, 8, 6, 2, 9, 2, 7, 2, 7, 8, 4, 2, 3, 0, 1, 9, 4, 7, 1, 5, 9, 1, 7, 3, 4, 3, 7, 1, 0, 3, 5, 9, 9, 4, 9, 6, 1, 7, 5, 9, 4, 9, 7, 3, 6, 7, 7, 4, 5, 3, 5, 3, 1, 5, 6, 1, 1, 9, 6, 6, 4, 0, 9, 4, 3。当n在[1,10]中取值时，请编写程序实现OPT、LRU、FIFO页面置换算法，并根据页面访问顺序模拟执行，分别计算缺页数量，画出缺页数量随页框数n的变化曲线（3条线） （代码附作业末） 4）一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表，12位到21位是第二级页表，页内偏移占0到11位。一个进程的地址空间为4GB，如果从0x80000000开始映射4MB大小页表空间，请问第一级页表所占4KB空间的起始地址？并说明理由。（注意B代表字节，一个32位地址占4字节） 计算方式与页目录自映射计算公式类似， 第一级页表所占4KB空间的起始地址为0x80000000|0x80000000>>10 = 0x80200000。 5） 进程整个的地址空间有2^32字节？一页有2^10字节。 0x0 过程：页目录地址为0x0，页表地址为0x0，页内偏移为0x0。 访问页目录0x0，有效位为0，访问无效。 0x00803004 过程：页目录地址为0x2，页表地址为0x3，页内偏移为0x4。 访问页目录0x2，得到页表的页框地址为0x5000且有效，访问页表0x3项，得到页框地址为0x20000且有效，加上偏移量即得到转换后的物理地址——0x20004。 最终访存获取到的数据为0x0。 0x00402001 过程：页目录地址为0x1，页表地址为0x2，页内偏移为0x1。 访问页目录0x1，得到页表的页框地址为0x1000且有效，访问页表0x2项，得到页框地址为0x5000且有效，加上偏移量即得到转换后的物理地址——0x5001。 最终访存获取到的数据为0x4e001。 物理地址0x326028对应的偏移量为0x28，对应的页框地址为0x32600，查找二级页表得，位于页框地址为0x20000的页表的第0x1项中，该页表信息位于页目录的第0x3项。 对应的虚拟地址为0x00c01028。 附：第三题代码import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;import java.util.Map;import java.util.Queue;public class MainClass { public static final int[] readpage = { 0, 9, 8, 4, 4, 3, 6, 5, 1, 5, 0, 2, 1, 1, 1, 1, 8, 8, 5, 3, 9, 8, 9, 9, 6, 1, 8, 4, 6, 4, 3, 7, 1, 3, 2, 9, 8, 6, 2, 9, 2, 7, 2, 7, 8, 4, 2, 3, 0, 1, 9, 4, 7, 1, 5, 9, 1, 7, 3, 4, 3, 7, 1, 0, 3, 5, 9, 9, 4, 9, 6, 1, 7, 5, 9, 4, 9, 7, 3, 6, 7, 7, 4, 5, 3, 5, 3, 1, 5, 6, 1, 1, 9, 6, 6, 4, 0, 9, 4, 3 }; public static void main(String[] args) { System.out.print(\"OPT: \"); for (int n = 1; n","permalink":"https://mondaycha.github.io/2020/03/25/325-1/","photos":["https://pic.downk.cc/item/5e7b6422504f4bcb040f2bb5.png"]},{"tags":[{"name":"推送","slug":"推送","permalink":"https://mondaycha.github.io/tags/%E6%8E%A8%E9%80%81/"}],"categories":[{"name":"写作","slug":"写作","permalink":"https://mondaycha.github.io/categories/%E5%86%99%E4%BD%9C/"}],"title":"学累了吗？要不要来听点什么……","date":"2020/03/24","text":"宅家学习，也是一场对专注力莫大的考验。 如何在学习时保持专注？ 在学习时听音乐能助于提升专注吗？ 本期就跟随小编来听听几名同学的看法， 也欢迎你在评论区留下自己的心得~ A：不听派学习的时候我一般都不会听音乐，感觉会让人更加分心。 周围环境比较嘈杂的时候，我会戴上耳塞。 有的人说会听白噪音有助于保持专注，但这主要还是看自己，专注的时候哪怕是车马喧嚣也听不见的。 B：习惯派会听，啥都听，感觉也没见有事…… C：分类派如果听音乐有助于集中注意力的话，其实我觉得可以。 在进行不是背诵等等的作业或者说背景很安静的时候，会选择听音乐来集中注意力。但我一般不会听中文（因为听得懂歌词会走神）以及太激烈的（比如摇滚）。 D：提神派我一般开始学习时都比较专注，这个时候也不需要音乐。 不过在稍微感到乏味或着说疲倦的时候，会用某音乐App的每日推荐功能。因为之前一般听纯音乐，所以推荐的也是这一类，最后在音乐的帮助下再次沉浸到现在做的事情中。 不管是什么派，只要能找到适合自己的方式就好。 你保持专注的方式是怎样的呢？欢迎来评论区留下你的心得~","permalink":"https://mondaycha.github.io/2020/03/24/324-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://mondaycha.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab2 学习笔记 (Part 1)","date":"2020/03/23","text":"前言挑战开始了，加油！！！ 双向链表操作拾遗在Exercise2.1，需要对双向链表进行操作。 在这里采用了一种特殊的链表形式，如上图（我找不到这个课件了，图片来自群成员） 链表的插入操作，对注释做了一点修正—— // Note: assign a to b a = b//Step 1, assign elm.next to listelem.next.//Step 2: Judge whether listelm.next is NULL, if not, then assign listelm.next.pre to a proper value.//step 3: Assign listelm.next to a proper value.//step 4: Assign elm.pre to a proper value. 这个设计感觉还是很巧妙的。 关于全局变量/* Step 1: Initialize basemem.* (When use real computer, CMOS tells us how many kilobytes there are). */basemem = 0x4000000;maxpa = 0x4000000;extmem = 0x0;// Step 2: Calculate corresponding npage value.npage = basenum >> 12; 后来看了一下在mmu.h里面有对SHIFT的定义，更严谨的来说应该是要写那个吧。 如何用命令行压缩文件压缩服务器上当前目录的内容为xxx.zip文件 zip -r xxx.zip ./* 解压zip文件到当前目录 unzip filename.zip 这样就可以从实验环境copy代码了！ 如何运行内核gxemul -E testmips -C R3000 -M 64 后面可以跟vmlinux的地址，也可以写个sh脚本来运行。 课程群零散知识点收集2.1 助教提示：typeof的使用 注释提示错误：应该是listelm->field.next->field.prev 2.2 npage指的是64MB/4KB extra那个填0（原因：根据输出判断为0，另一方面我们就没有外置存储，gx模拟的时候没有模拟你额外插内存条） Debug记录1Exercise2.1 双向链表操作错误 借助pb的test程序 2Exercise 2.4，输出如下结果—— -------------------------------------------------------------------------------main.c: main is start ...init.c: mips_init() is calledPhysical memory: 65536K available, base = 65536K, extended = 0Kto memory 80401000 for struct page directory.to memory 80431000 for struct Pages.pmap.c: mips vm init success[ dev_mp: unimplemented relative addr 0x8 ][ dev_mp: unimplemented relative addr 0x14 ]Segmentation fault (core dumped) 初步分析：与pmap.c中的三个函数填写有关 检查警告—— pmap.c: In function 'page_init':pmap.c:183: warning: passing argument 1 of 'va2pa' from incompatible pointer typepmap.c: In function 'page_alloc':pmap.c:230: warning: passing argument 1 of 'bzero' makes pointer from integer without a cast 说明type不对，进行修改完成debug工作。","permalink":"https://mondaycha.github.io/2020/03/23/323-2/","photos":["https://pic.downk.cc/item/5e78981c5c56091129c65218.png"]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://mondaycha.github.io/tags/Git/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"如何使用Git从远程仓库获取所有分支","date":"2020/03/23","text":"git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; donegit fetch --allgit pull --all 来源：Stackoverflow 链接：http://stackoverflow.com/questions/10312521/how-to-fetch-all-git-branches","permalink":"https://mondaycha.github.io/2020/03/23/323-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab1 实验报告","date":"2020/03/21","text":"OS Lab1 实验报告一、实验思考题思考题0.1也许你会发现我们的readelf程序是不能解析之前生成的内核文件(内核文件是可执行文件)的，而我们之后将要介绍的工具readelf则可以解析，这是为什么呢？(提示：尝试使用readelf -h，观察不同) 答： 通过readelf -h可以发现，我们之前生成的内核文件vmlinux是大尾端elf文件，而测试使用的testELF是小尾端elf文件。 ~/work/18373580-lab/gxemul$ readelf -h vmlinuxELF Header: Magic: 7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, big endian ... ~/work/18373580-lab/gxemul$ readelf -h ../readelf/testELFELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian ... 由于我们的readelf程序尚未完善，目前只能在小尾端环境下运行，无法正确读取大尾端elf文件的内容，因此不能正确输出段头表内信息。在Lab1-extra中通过对readelf的补充修改，就可以进行解析了。 思考题0.2内核入口在什么地方？main 函数在什么地方？我们是怎么让内核进入到想要的 main 函数的呢？又是怎么进行跨文件调用函数的呢？ 答： 内核在kseg0内，main 函数在User Space(kuseg)内。 在本次Lab1中，scse0_3.lds里通过ENTRY(_start)指令指定了start.S中的_start()函数指向内核入口。main 函数路径为init/main.c。 _start()函数初始化CPU，设置栈指针，通过jal指令让内核跳转到main函数。在链接可执行文件之后通过跳转指令跨文件调用函数。 二、实验难点图示不传图了 三、体会与感想Lab1难度评价：★★★☆☆ Lab1-extra难度评价：★★★☆☆ 花费时间：Lab1 9h，Lab1-extra2h 体会和感想： 在Lab1我感受到了深深的恐惧。我意识到了如果我不再采取策略，很快我就会难以跟上目前的进度。 在这一节中难点是print函数的补充，然而一开始我却毫无思路，参考PPT和Ausar的指导书补充才填写出来；而在Lab1-extra，我花费了大量的时间de翻转函数的bug，如果是课上测试的话根本做不出；思考题0.2更是让我一头雾水，不清楚题目表达的意思。 目前正在读指导书和ELF手册，我非常迷茫，但OO将占据我的另一大半时间……完全不清楚要采取什么策略来学习，也只能走一步看一步了。 最后是对于接下来Lab的想法： 在开始Lab之前，获取全部资料（Lab1的资料我觉得很分散，让人摸不到头脑） 对于不理解的内容，搜集相关资料（但真的太杂了，系统差别也大） 祈祷我能存活下去吧。","permalink":"https://mondaycha.github.io/2020/03/21/321-1/","photos":[]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week4","date":"2020/03/20","text":"爱课程 3.4 探月工程发展在这节课我学习到，嫦娥三期工程，中国整个探月工程分为“绕”、“落”、“回”3个阶段。第一步，第一颗月球探测卫星“嫦娥一号”已于2007年10月24日发射；第二步是发射月球软着陆器，突破地外天体的着陆技术；第三步是发射月球软着陆器，突破自地外天体返回地球的技术，进行月球样品自动取样并返回地球。 爱课程 2.1 流体流动基本规律在这节课我学习到，航空基于空气动力学原理，航空器需要有足够的升力。航空器能够良好的飞行需要三个要素——足够升力、足够动力、良好的稳定性。流体流动基本规律有质量守恒与连续性方程，得到速度与截面的关系——截面积大，流速变小。能量守恒与伯努利方程，静压加动压为常数，流速大，动压大。课上的“茅屋为秋风所破”的例子也很生动形象。 爱课程 2.2 飞机的升力在第二节，我学习到，飞机上下翼的流速不同，上下翼面形成压强差，从而产生了升力，使得飞机平衡了重力。影响升力的因素有——翼面积、飞行速度、空气密度、翼型和迎角（风筝产生升力的原因）。迎角过大会引起失速，不利于起降，借助襟翼增升装置可以实现平稳起降。高升力、低阻力是设计飞机的永恒目标。 学堂在线 3 探月工程在学堂在线的3.7/9/9，我学习到，“嫦娥一号”是我国第一颗月球探测卫星，突破了很多关键技术，飞行轨道设计就是关键的一环。中国整个探月工程分为“绕”、“落”、“回”3个阶段。嫦娥三号在月球上成功软着陆，有着非常重要的意义。嫦娥五号则将实现“回”，与前面几个探测器不同，预计于2020年发射。 嫦娥四号在月球背面着陆有什么意义？之所以人类对于月球的探索都集中在正面，是因为在背面的着陆难度远远大于正面。月球背面接收不到来自地球的任何辐射干扰，飞行器无法与地面取得联络。中国成功部署了“鹊桥号”中继卫星，为嫦娥四号在月球背面着陆做好了准备。嫦娥四号在月球背面着陆，可以采集月球背面的特有信息，而嫦娥四号任务更是为中国航天迈出了突破性的一步。 我国北斗卫星导航系统有哪些功能？我国北斗卫星导航系统已广泛应用于交通运输、基础测绘、工程勘测、资源调查、地震监测、气象探测和海洋勘测等领域。具体的功能如下： 基本导航服务。为全球用户提供服务，空间信号精度将优于0.5米；全球定位精度将优于10米，测速精度优于0.2米/秒，授时精度优于20纳秒；亚太地区定位精度将优于5米，测速精度优于0.1米/秒，授时精度优于10纳秒，整体性能大幅提升。 短报文通信服务。中国及周边地区短报文通信服务，服务容量提高10倍，用户机发射功率降低到原来的1/10，单次通信能力1000汉字（14000比特）；全球短报文通信服务，单次通信能力40汉字（560比特）。 星基增强服务。按照国际民航组织标准，服务中国及周边地区用户，支持单频及双频多星座两种增强服务模式，满足国际民航组织相关性能要求。 国际搜救服务。按照国际海事组织及国际搜索和救援卫星系统标准，服务全球用户。与其他卫星导航系统共同组成全球中轨搜救系统，同时提供返向链路，极大提升搜救效率和能力。 精密单点定位服务。服务中国及周边地区用户，具备动态分米级、静态厘米级的精密定位服务能力。 （参考资料：百度百科）","permalink":"https://mondaycha.github.io/2020/03/20/320-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OO 第一单元总结 表达式求导","date":"2020/03/19","text":"OO 第一单元总结 表达式求导OO第一单元通过三次递进式的作业让我们实现表达式求导，在这几次作业中我也有很多收获。下面就回顾一下前三次作业中存在的问题。 在个人看来，表达式求导的难点主要有三部分——对输入的处理、表达式的存储结构以及化简。这三次作业我所采用的表达式存储结构都不相同，不过重构的速度还是比较快的（安慰自己）。 第一次作业在第一次作业中，我的程序总体架构为提取幂函数为Poly对象，建立Polynomial类解析表达式创建幂函数对象，在主类Derivative中进行部分性能优化工作。 ① 程序结构分析UML类图： 第一次作业的幂函数因子较为简单，代码中仅提炼出Poly对象，并在其内部实现求导方法。 Method复杂度： Method ev(G) iv(G) v(G) Derivative.main(String[]) 1 1 1 Derivative.printAnswer(HashMap) 4 5 7 Poly.Poly(BigInteger,BigInteger) 1 1 1 Poly.addCoef(BigInteger) 1 1 1 Poly.compareTo(Object) 1 1 1 Poly.derivative() 1 2 2 Poly.equals(Object) 2 2 2 Poly.getCoeff() 1 1 1 Poly.getIndex() 1 1 1 Poly.hashCode() 1 1 1 Poly.toString() 1 11 12 Polynomial.Polynomial(String) 1 1 1 Polynomial.getPolyitem() 1 2 2 Polynomial.getfirstitem() 1 9 10 第一次作业中，化简主要在主类Derivative的printAnswer()方法（将第一个正项优先输出）和Poly类的toString()方法中，printAnswer()涉及对表达式的遍历，基本复杂性高；toString()则包含大量条件语句，多次调用了BigInteger中的方法，循环依赖性高。而表达式解析我采用的是正则+状态机的策略（这个策略三次作业均沿用，感觉还是很舒服的），在getfirstitem()中处理不同类型输入并归一化，代码较为复杂。 ② 程序Bug分析第一次作业在强测、互测中均未出现Bug。 ③ 互测采用策略互测时我采用的策略是“补刀”。我先是用简单的自动测试程序跑了下房间内成员的代码，不过貌似没有出现问题；然而圣杯战争发生了转机——Rider竟然拿下了一血！ 于是我一一检查其他成员的代码，发现Berserker的正则存在问题：在正则中匹配的是“[+|-]{0,2}(\\\\d*.)?x(..[+|-]?\\\\d+)?”，其中的“.”可匹配任意字符，就会错误解析表达式。 第一次互测时认真读了屋内其他同学的代码，感觉还是很有收获的。之后两次大部分都读不下去，可读性实在是让人肝疼……放到评测姬里自生自灭吧！另外这次互测也让我意识到了高工同学的可怕之处（误），全屋子就这一个Bug，大佬换着花样hack……卷卷更健康。 ④ 对象创建模式在第一次作业中，我并没有应用对象创建模式，表达式解析就顺便new了新因子，Polynomial类的紧耦合比较严重。 第二次作业第二次作业增加了三角函数因子，这个时候我也偷偷看了一下去年的第三次作业题目，新增加的嵌套对于表达式的化简无疑是不小的挑战。所以在规划第二次作业的总体架构时，我就面临着一个选择——是要建立终将在第三次作业重构的四元组项；还是要采用“表达式-项-因子”三层结构，为第三次作业留好迭代的空间？ 经过一番挣扎（其实并没有，因为我还不会写三层结构），我选择了势必带来重构的四元组形式，也就是将表达式的每一项以“coeff*x**powindex*sin(x)**sinindex*cos(x)**cosindex”的形式存储，这样处理方式就和第一次作业基本一致。在基本架构沿用第一次作业的情况下，第二次作业给我最大的挑战反而是三角函数的化简，我的化简类Simplify的行数是最多的。 ① 程序结构分析UML类图： 架构基本沿用第一次作业，UML也差不多，不过这次的简化更复杂一些。 Method复杂度： Method ev(G) iv(G) v(G) DeriPrinter.DeriPrinter(HashMap) 1 7 7 DeriPrinter.getAnswer(HashMap) 4 5 7 DeriPrinter.printAnswer() 1 2 2 Item.Item(BigInteger,BigInteger,BigInteger) 1 1 1 Item.compareTo(Object) 3 3 3 Item.equals(Object) 2 4 4 Item.getCosin() 1 1 1 Item.getPowin() 1 1 1 Item.getSinin() 1 1 1 Item.hashCode() 1 1 1 Item.toString() 1 5 8 MainClass.main(String[]) 1 1 1 MutiItem.MutiItem(BigInteger,BigInteger,BigInteger,BigInteger) 1 1 1 MutiItem.MutiItem(BigInteger,Item) 1 1 1 MutiItem.addCoeff(BigInteger) 1 1 1 MutiItem.compareTo(Object) 1 1 1 MutiItem.derivate() 1 5 5 MutiItem.equals(Object) 2 2 2 MutiItem.getCoeff() 1 1 1 MutiItem.getCosin() 1 1 1 MutiItem.getIdentity() 1 1 1 MutiItem.getItem() 1 1 1 MutiItem.getPowin() 1 1 1 MutiItem.getSinin() 1 1 1 MutiItem.hashCode() 1 1 1 MutiItem.toString() 1 5 5 ParseExp.MutiItemSign() 2 3 4 ParseExp.ParseExp(String) 1 5 6 ParseExp.WrongFormat(String) 1 1 1 ParseExp.getExpression() 1 2 2 ParseExp.getFirstitem() 3 13 14 Simplify.Simplify(HashMap) 1 2 2 Simplify.exitmatch(BigInteger,Item,Item,Item,HashMap) 2 3 4 Simplify.searchcos(HashMap) 4 6 9 Simplify.simplify() 1 3 4 由于一开始并没有明确的化简思路，在第一遍实现了基本求导功能的代码通过中测之后，我为了实现化简功能，又对代码内类的结构做了很多修改，在这一过程中，尽管我确实用类将表达式中的Item与MulItem做了封装，但我却胡乱修改内部方法，这并不符合面向对象的思想，也导致最后代码可读性极差，也为互测时被发现的Bug埋下了祸根。具体表现到MetricReloaded的分析上，就是ParseExp类的getFirstitem()依然是复杂度重灾区，没有采用工厂模式也使得它与其他类的依赖极为严重，优化输出的内容依然有很高的基本复杂性。 ② 程序Bug分析强测中获得性能分为16.545/20，在处理表达式化简时，我所采用的是暴力搜索的方式，每次搜索到可以合并的项就将其合并，然后进行重新搜索。 这种方法显然只能找到一个极优解，却不能找到最优解，表达式项存储顺序对结果也有很大影响。一种更加可行的方式是采用深度优先搜索，不过当时并没有想出具体的实现方法，只好作罢。 互测时被找出来一个Bug，同时发现Berserker的一个Bug（狂战士日常躺枪）。而我的Bug是HashMap的Key写错，在生成MulItem的Key时，我采用的是将指数拼接为String的方式，在指数较大时，可能会导致不同项被当作同一项存入HashMap中，造成求导错误。 修改也很简单，只需要在生成String的时候给不同指数加个分隔符就好了—— public MutiItem(BigInteger a, BigInteger b, BigInteger c, BigInteger d) { this.coeff = a; this.item = new Item(b, c, d); // before: identity = \"\" + b + c + d; identity = \"\" + b + \".\" + c + \".\" + d;} 可以发现这里我的MutiItem的构造方法是非常混乱的，不过没有发现这么明显的Bug，一方面就是混乱的优化带来的副作用；另一方面也是因为这样的数据出现几率确实很小，同屋里也只有一个同学发现了这个Bug（我后来和hack我的同学交流了下，果然是长时间跑随机自动测试程序才找到的……） ③ 互测采用策略在这次互测是采用对拍+手动构造样例+Python生成随机数据自动评测的方式。屋内除我只有一个Bug，大家很快找到之后也比较佛系。 互测中阅读了同屋子大佬处理简化的DFS，确实厉害；另外还拜读了另一个房间Alterego的架构，类似Sympy的表达式结构简直叫人拍案叫绝，计算方式优美，让我看到了什么是真正的封装、多态、继承，也有更多信心去面对第三次作业。（不过听说在那个屋Alterego被hack的很惨，悲） ④ 对象创建模式在第二次作业中，由于使用的是和第一次作业类似的四元组项，我依然没有应用对象创建模式，表达式解析里又new了新因子，紧耦合依然严重。这在第三次作业中有一定改善。 第三次作业前两次作业都没有对表达式进行结构化处理，导致了第三次作业表达式的存储结构必须大改。 好在表达式求导的三大难点——对输入的处理、表达式的存储结构以及化简，这次都处理得比较好—— 对输入的处理上，有了前两次作业中采用的正则表达式加有限状态机读入的经验，修改很快； 表达式的存储结构上吸取了Alterego的架构（感谢Alterego！！！！），在进行重构的时候思路比较清晰，避免了第二次作业惨剧的重演； 化简上，层次化的表达式存储方式发挥出了它的优越性，通过统一的接口进行因子类型的转换，效果好； 在第三次作业我也首次采用了Package来管理类，也是一个小进步。 ① 程序结构分析UML类图： 这一次的类图很乱，主要原因还是在于表达式也可以作为一个因子嵌套进三角函数中，类之间的相互调用也比较明显。 Method复杂度： Method ev(G) iv(G) v(G) homework.MainClass.main(String[]) 1 2 2 homework.expression.ExpFunction.Exception.Exception(String) 1 1 1 homework.expression.ExpFunction.deleteSpace(String) 3 7 10 homework.expression.ExpFunction.matchParentheses(String,int) 6 6 7 homework.expression.ExpFunction.readIndex(String) 2 1 2 homework.expression.ExpFunction.simplifyExpParentheses(String) 9 11 14 homework.expression.ExpFunction.simplifyParentheses(String,int[]) 1 1 8 homework.expression.ExpFunction.simplifySign(String) 4 3 4 homework.expression.ExpParser.Exception.Exception(String) 1 1 1 homework.expression.ExpParser.ExpParser(String) 3 2 3 homework.expression.ExpParser.getItemAdd(String,boolean) 5 6 9 homework.expression.ExpParser.getItemMul(String) 4 3 5 homework.expression.ExpParser.matchParentheses() 7 4 8 homework.expression.ExpParser.readOneItem(String) 6 9 12 homework.expression.ExpParser.spliter() 1 1 1 homework.expression.ExpSimplify.ExpSimplify(Derivable) 1 2 2 homework.expression.ExpSimplify.OnlyOneDiff(Derivable,Derivable) 9 17 26 homework.expression.ExpSimplify.getDiff(boolean,int,int,ItemMul,ItemMul) 1 4 6 homework.expression.ExpSimplify.searchSimplify(ItemAdd) 4 4 4 homework.expression.ExpSimplify.simplify() 2 2 4 homework.polyitem.factor.Factor.Factor() 1 1 1 homework.polyitem.factor.Factor.Factor(BigInteger) 1 1 1 homework.polyitem.factor.Factor.getIndex() 1 1 1 homework.polyitem.factor.Factor.setIndex(BigInteger) 1 1 1 homework.polyitem.factor.Factor.updateIndex(BigInteger) 1 1 1 homework.polyitem.factor.FactorExp.FactorExp() 1 1 1 homework.polyitem.factor.FactorExp.FactorExp(ItemAdd) 1 1 1 homework.polyitem.factor.FactorExp.FactorExp(ItemAdd,BigInteger) 1 1 1 homework.polyitem.factor.FactorExp.clone() 1 1 1 homework.polyitem.factor.FactorExp.derivate() 4 4 5 homework.polyitem.factor.FactorExp.equals(Object) 3 3 4 homework.polyitem.factor.FactorExp.equalsZero() 1 1 1 homework.polyitem.factor.FactorExp.getExpression() 1 1 1 homework.polyitem.factor.FactorExp.identity() 1 1 1 homework.polyitem.factor.FactorExp.toString() 1 4 4 homework.polyitem.factor.FactorFactory.readPower(Matcher) 1 2 2 homework.polyitem.factor.FactorFactory.readTrian(Matcher) 1 2 3 homework.polyitem.factor.FactorFactory.simplifyFunc(Derivable) 2 4 5 homework.polyitem.factor.FuncConst.FuncConst() 1 1 1 homework.polyitem.factor.FuncConst.FuncConst(BigInteger) 1 1 1 homework.polyitem.factor.FuncConst.FuncConst(String) 1 1 1 homework.polyitem.factor.FuncConst.clone() 1 1 1 homework.polyitem.factor.FuncConst.derivate() 1 1 1 homework.polyitem.factor.FuncConst.equals(Object) 2 2 2 homework.polyitem.factor.FuncConst.equalsOne() 1 1 1 homework.polyitem.factor.FuncConst.equalsZero() 1 1 1 homework.polyitem.factor.FuncConst.getValue() 1 1 1 homework.polyitem.factor.FuncConst.identity() 1 1 1 homework.polyitem.factor.FuncConst.setValue(BigInteger) 1 1 1 homework.polyitem.factor.FuncConst.toString() 1 1 1 homework.polyitem.factor.FuncConst.updateValue(BigInteger) 1 1 1 homework.polyitem.factor.FuncPower.FuncPower() 1 1 1 homework.polyitem.factor.FuncPower.FuncPower(BigInteger) 1 1 1 homework.polyitem.factor.FuncPower.clone() 1 1 1 homework.polyitem.factor.FuncPower.derivate() 1 1 2 homework.polyitem.factor.FuncPower.equals(Object) 2 2 2 homework.polyitem.factor.FuncPower.equalsZero() 1 1 1 homework.polyitem.factor.FuncPower.identity() 1 1 1 homework.polyitem.factor.FuncPower.toString() 1 1 2 homework.polyitem.factor.FuncTrian.FuncTrian() 1 1 1 homework.polyitem.factor.FuncTrian.FuncTrian(boolean) 1 1 1 homework.polyitem.factor.FuncTrian.FuncTrian(boolean,BigInteger) 1 1 1 homework.polyitem.factor.FuncTrian.FuncTrian(boolean,ItemAdd) 1 1 1 homework.polyitem.factor.FuncTrian.FuncTrian(boolean,ItemAdd,BigInteger) 1 1 1 homework.polyitem.factor.FuncTrian.clone() 1 2 2 homework.polyitem.factor.FuncTrian.derivate() 4 4 6 homework.polyitem.factor.FuncTrian.equals(Object) 6 4 8 homework.polyitem.factor.FuncTrian.equalsZero() 3 3 4 homework.polyitem.factor.FuncTrian.identity() 1 4 5 homework.polyitem.factor.FuncTrian.toString() 1 2 3 homework.polyitem.item.ItemAdd.ItemAdd() 1 1 1 homework.polyitem.item.ItemAdd.ItemAdd(Derivable…) 1 3 3 homework.polyitem.item.ItemAdd.ItemAdd(HashMap) 1 1 1 homework.polyitem.item.ItemAdd.ItemAddPut(Derivable) 1 4 4 homework.polyitem.item.ItemAdd.PutItemMul(ItemMul) 1 5 5 homework.polyitem.item.ItemAdd.clone() 1 2 2 homework.polyitem.item.ItemAdd.derivate() 2 2 3 homework.polyitem.item.ItemAdd.equals(Object) 3 2 3 homework.polyitem.item.ItemAdd.equalsZero() 3 2 3 homework.polyitem.item.ItemAdd.getAdditem() 1 1 1 homework.polyitem.item.ItemAdd.getOnlyOne() 4 2 4 homework.polyitem.item.ItemAdd.identity() 1 1 1 homework.polyitem.item.ItemAdd.onlyContainOne() 1 1 1 homework.polyitem.item.ItemAdd.toString() 6 5 7 homework.polyitem.item.ItemMul.ItemMul() 1 1 1 homework.polyitem.item.ItemMul.ItemMul(Derivable…) 3 3 3 homework.polyitem.item.ItemMul.ItemMulPut(Derivable) 3 5 6 homework.polyitem.item.ItemMul.PutFactor(Factor) 6 10 10 homework.polyitem.item.ItemMul.PutItemMul(ItemMul) 1 2 2 homework.polyitem.item.ItemMul.clone() 1 2 2 homework.polyitem.item.ItemMul.derivate() 6 2 7 homework.polyitem.item.ItemMul.equals(Object) 3 2 3 homework.polyitem.item.ItemMul.equalsZero() 3 2 3 homework.polyitem.item.ItemMul.getCoeff() 2 2 2 homework.polyitem.item.ItemMul.getMutiitem() 1 1 1 homework.polyitem.item.ItemMul.getOneExp() 5 2 5 homework.polyitem.item.ItemMul.identity() 2 3 4 homework.polyitem.item.ItemMul.negateCoeff(boolean) 1 2 2 homework.polyitem.item.ItemMul.onlyOneExp() 3 3 7 homework.polyitem.item.ItemMul.onlyOneFactor() 4 3 7 homework.polyitem.item.ItemMul.removeItem(Derivable) 1 2 2 homework.polyitem.item.ItemMul.setCoeffOne() 1 1 1 homework.polyitem.item.ItemMul.toString() 1 7 7 homework.polyitem.item.ItemMul.updateCoeff(BigInteger) 1 1 1 MetricReloaded分析程序复杂度更加病态了，大量方法的结构化程度存在问题，并且集中在与化简有关的方法中。表达式解析中的readOneItem()方法三项均超标，虽然我已经进行了采用了一部分的工厂模式、将正则表达式存入单独的类中以被调用的解耦合的努力。 Package复杂度： Package v(G)avg v(G)tot homework 2 2 homework.expression 6.68 127 homework.polyitem.factor 1.86 93 homework.polyitem.item 3.38 115 通过分包，将几大功能区分开（不过这次看到20%的性能分，增加了暴力搜索提取公因式的简化方法，还是放在Exp处理中，所以耦合度也有点高）。 ② 程序Bug分析“OO中最惨的，不是被同屋hack了50个同质Bug，而是在截止提交的下一秒意识到了自己的Bug” ——沃茨基·硕德 在第三次作业中，我为了简化做了不少工作，也用随机数据自动测试程序做了大量的检验。然而就在周六晚上截止提交后的几秒，我突然意识到我的输出是有问题的——对于表达式因子，我将其设置为继承了Factor类，同样拥有指数Index属性，在输出时，采用的是和幂函数、三角函数一样的输出方式——“`(exp)**index`”，但在输入时表达式因子是不允许有指数的，因此属于WF。但对于Sympy，表达式的格式限定很宽松，通过计算并不能找到错误。 那能咋办……周六晚上看番转移注意力，周日在互测中尽可能挽回损失……最后发现强测没有出现这种输出，但互测时被同屋两名Servent发现了这个Bug。好在修复工作也比较简单，实在是侥幸。 ③ 互测采用策略在这次互测依然是采用对拍（对军宝具）+手动构造样例（我自己构造了可能会TLE的样例，也分享到了群里）+Python生成随机数据自动评测的方式。 在这次对Python生成随机数据做了优化，比如Caster在指数为0时会出现各种吊诡的错误，然而互测限定指数>0，于是我将对Caster的随机数据设为指数始终>0，其他成员照旧，避免了反复查看不能hack的Bug带来的失落感。 最后稍微吐槽一下“不优化就不会Die”，在这次互测中，房间内8名成员，4名优化输出4名不优化，最后出Bug的都是那4名优化输出的……其中Berserker还会在表达式嵌套过多时陷入死循环，截止至本文发稿时已被修好。 ④ 对象创建模式在这次的作业中终于用到了工厂模式！虽然原因是表达式解析方法太长，不得不将生成项的代码独立开来。不过我也只用工厂模式处理了幂函数、不含嵌套因子的三角函数、常数，含嵌套因子的三角函数的生成与我的状态机密切相关，难以抽象出来，这也是我的架构中的不足。 心得体会在寒假的时候，我曾看到知乎上@HansBug学长关于OO课程改革的回答，而通过这一个多月的实际体验，OO给我的感受还是很赞的，通过互测阅读同学代码、与舍友们的交流（感谢@VOIDMalkuth！！！）、水讨论区以及学习理论课，收获很大。 第一单元也只是从面向过程到面向对象的过渡篇章，通过这次反思，我也发现了过去几次代码中自己结构较为不合理的部分，希望能够在接下来多线程等知识的学习中进一步改善。","permalink":"https://mondaycha.github.io/2020/03/19/319-3/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://mondaycha.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"卑！忘了经济管理课的签到","date":"2020/03/19","text":"不能再摸鱼了！！！！！！ 啊啊啊啊啊！！！！！！！","permalink":"https://mondaycha.github.io/2020/03/19/319-2/","photos":[]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week3","date":"2020/03/19","text":"1.3 中国航空航天技术的发展在这次的慕课中我学习到，中国航空事业的蓬勃发展是从新中国成立之后开始的，中国航天事业是在上世纪50年代中期开始的，1956年，我国制定了12年科学发展远景规划，把火箭和喷气技术列为重点发展项目。从开国大典时的17架飞机绕回再飞，到今天的强大航空航天力量，中国的发展让人心潮澎湃。 2 中国航空技术的发展在第二章我学习到，为中国航空做出巨大贡献，被称为中国“航空先驱”的是冯如。一直以来，听说北航的“冯如书院”、“冯如杯”，没有想到原来冯如先生的成就如此之高。当今中国航空界也以“冯如一号”首飞成功的1909年为中国航空元年。 3 中国航天技术的发展在这一章我学习到，1956年，我国制定了12年科学发展远景规划，两弹一星、载人航天八大系统、中国载人航天的第一步——将航天员送上太空，第二步——太空行走与太空对接；第三步——建设空间站。虽然最近的长七改发射失利，但未来一定会更好。 C919的市场前景 在国内，C919还有着广阔的市场 中国的商用大飞机的路还很长，更多是改变既有的国际贸易规则； 新型冠状病毒疫情下，航空运输业面临着严峻的挑战，不容乐观 疫情也是中国的机会，借C919打破现有的国际贸易规则，飞向未来 太空站的建设有什么意义？ 航天事业的发展，离不开空间站。 为从事科学实验，提供良好研究条件。是地面上无法复制、无法替代的特殊科研环境。 2024年国际空间站退役，为中国带来新的机会 提升我国国际地位，向星辰大海探索","permalink":"https://mondaycha.github.io/2020/03/19/319-1/","photos":[]},{"tags":[{"name":"航概","slug":"航概","permalink":"https://mondaycha.github.io/tags/%E8%88%AA%E6%A6%82/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"《航空航天概论》Week2","date":"2020/03/09","text":"2.1 世界航空技术发展在第一节，我学习到了大气层划分为对流层、平流层、中间层、热层和散逸层（外大气层）等5个层次。航空器的大气飞行环境是对流层和平流层。老师介绍了最早的航空器——热气球（轻于空气的航空器）、飞艇等，美国的莱特兄弟制作的第一架有动力飞机飞行者一号立下了航空的里程碑。而之后一战、二战的作战飞机的设计也让人惊叹，从活塞发动机到喷气时代的变化也让人感受到航空航天的魅力。而对于目前的四代机来说，隐身、超声速巡航、过失速机动，超视距攻击四种能力也非常重要。第二节则重点介绍了关于飞机的内容。从第四代直升机的研发，到现代民用飞机的发展。超声速客机与新一代的民用客机，让我们不禁开始展望航空的美好未来。航空也有着更高、更快、更远、更大的发展方向，民用飞机将更加安全，更加舒适，更加经济，更加环保。 2.2关于世界航天技术发展，在第一节，我了解到了齐奥尔尔科夫斯基的多级火箭成为了现在航天器发展的基础。v2火箭成为了现代大型火箭的鼻祖。在太空竞赛之中，航天也得到了长足的发展。对于今天的我们来说，航天探索已经变得稀松平常，但人类要想要迈出太阳系，还有很长的路要走。 2.3人造地球卫星。 航天器有无人航天器与载人航天器、军用航天器与民用航天器的划分，与我们的日常生活、经济发展、科研探测等密切相关的就是人造地球卫星。 人造地球卫星中的科学卫星可用于空间天文的探测技术；试验卫星可用于新技术的实验应用；应用卫星可用于日常勘测行为。 中国目前的北斗导航系统也让我们不再受制于GPS。 歼-10。 首先对于中国来说，它是我国国防现代化建设的一个里程碑，意味着中国成为了世界上第五个具备独立研制四代机能力的国家。 其次，歼-10所采用的数字电传飞控系统优良的气动外形，也无不是21世纪人类科技的结晶。 对于中国来说，歼-10的出现也提高了我国的制空能力，增强了我们的民族信心。","permalink":"https://mondaycha.github.io/2020/03/09/312-1/","photos":[]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"},{"name":"影评","slug":"影评","permalink":"https://mondaycha.github.io/tags/%E5%BD%B1%E8%AF%84/"}],"categories":[{"name":"摘录","slug":"摘录","permalink":"https://mondaycha.github.io/categories/%E6%91%98%E5%BD%95/"}],"title":"《来自缤纷世界的明日》— 摆脱黑暗去迎接明天","date":"2020/03/09","text":"作者：信评动画https://www.bilibili.com/read/cv1779317出处： bilibili 《来自缤纷世界的明日》完结撒花！ 本作是由P.A.Works带来的又一部原创作品，真的还是得夸赞PA总是能够持续不断的带给我们优质的原创动画作品啊！不过本作看下来，虽然算是相当精彩，但是却好像少了点什么的感觉，我们今天就来谈谈这件事吧！ 和我以前所说到的《Banana Fish》类似，这个作品也是非常的稳，故事的推进也好情绪的堆叠也好都处理的很棒；不过比起故事本身就充斥着冲突与张力的Banana Fish，本作的稳，甚至是在故事的推进中都缺乏了一些特别夺人目光的故事张力，让作品整体也开始变得相对平淡。但我自己对于这样平淡的处理也还是蛮喜欢的，因为在这样淡然的情节之中，才更贴近我们所认知到得青春日常嘛。而且比起那些刻意构筑出人物之间冲突的作品，本作选择慢慢的去把几个角色之间的人物关系给慢慢的晕开，让这样的氛围渐渐感染女主瞳美，让瞳美渐渐的感受到幸福的感觉；这样的做法还是很能够把情绪慢慢的导入观众的心中，去体会她所感受到的感动的。 所以说这部作品真正好看的地方反倒不是它那花哨的设定，不是魔法、不是穿越也不是失去色彩的瞳美，而是对于青春日常那真实的还原。那么这里就可以把话题带回到我开篇所提到的那个问题，这部作品在青春日常的情感表现我相信有不少观众和我一样为之动容，那么为什么看到最后会有一股少了点什么的感觉呢？我认为理由就是作品其实并没有很好的去利用这些设定，相关的细节也阐述的不是很透彻，所以到最后这些设定的存在就会变得很暧昧，才会有这样的感觉吧！ 尤其在故事发展到靠后的时期，才让瞳美穿越时空的副作用显现出来，这就像是一记警钟，不仅敲响了故事里的大家开始为瞳美是否会消失的担心以及对于她要离去的伤心，更是让我们观众突然想起很可能早就被遗忘的设定。而这突如其来的事件，让作品必须要在所剩的3集里面把原本抛出来的问题给迅速解决，让作品本来那缓慢又细腻的情感与故事，被逼迫着要加速起来。而这个加速，就有点破坏掉前期因缓慢所铺垫好的氛围和情绪了，这才是这部作品的问题所在。其实如果作品早一点的去交代这个副作用的存在，并让它随着剧情的推进越来越严重，让作品的基调能在平和的表面底下始终保存着一丝紧张感的话，这种突如其来的加速所造成的观感瞬差，我相信就会少很多吧！ 当然这个问题其实也并不是很严重，因为作品在前期那庞大的情绪铺垫依旧非常的强劲，作品到最后虽然有些仓促但是一切的展开都非常的合情合理，除了最后回到60年后的有些地方我认为可以处理得更好之外，整部作品完整的看下来，还是相当优秀的。也因此，我前面那些并不是在多么的苛责作品的问题，只是提出作品那本来可以处理的更好的部分。 也就是说，故事这样的设定是没有问题的，甚至我可以说这个设定是真的很有意思且很有新意的。像是作品中的魔法元素，在我看过的这么多有着魔法元素的作品以来，这还应该是第一次把魔法这个元素处理得那么日常，这真的是很难得且很有趣的一个思路。毕竟以往的故事，只要提到魔法，就会直接与神秘挂钩，总是要遮遮掩掩不被其他人发现，并把世界分割成表里世界。但是在本作中这个魔法却不是什么神秘的东西，甚至都已经开店售卖相关的魔法商品，让大家随意购买。这样的设计让魔法的这个元素不会与作品的青春校园氛围格格不入，也不会因为要掩藏这件事情而产生什么过分的张力冲突，不让故事因为魔法而变得沉重。相反地，虽然就算把这个元素完全从作品中删除也不会影响到故事的核心，但是故事中很多动人的场面，却都和魔法脱离不了干系；换言之，魔法元素的加入，为这个作品添加了许多色彩，而这对于瞳美来说也是一样的。 来自未来的瞳美看不到色彩，她眼中的世界是黑白的。也因为这样，她刻意的和周遭的人疏远，害怕自己所看到的世界和别人不一样所以产生不了共鸣。为了解决这件事还有个人的原因，瞳美的奶奶琥珀将她送往60年的过去，去让她真正的经历一次青春，去亲自掌握并感受这世界的色彩。随着故事的推展，其实就会发现无论是身为魔女的她施展不了魔法，还是她看不见世界的色彩，都是她自己对于自己的内心的一道枷锁。瞳美越是内敛、内向，越是把自己封印起来，她离彩色的世界就越遥远；但是回到过去所结交的那群朋友，逐渐的将她从泥沼中拉拔出来，逐渐的打碎她所赋予她自己的枷锁，让她到最后，终于看见了世界的斑驳，终于完全的从那黑暗的过去给走了出来。而目睹着这一切的我们，是不是也有可能稍微的因为这个故事，而从黑暗中走出来一点点呢？世界本来就是缤纷的，唯一能够把它涂抹成一片黑白暗淡的，只有我们自己；当然要我们自己独立的走出来并不容易，但是当你如同故事里的瞳美一样幸运，找到一群很好的伙伴，并因此找到幸福感的时候，只要你愿意，迎接你的未来，我相信就会是五彩缤纷的明天！ 总的来说，本作算是一个相当优秀的作品，虽然部分情节上的处理有些缺陷，但是对于大体上的观感没有剧烈的伤害，而且故事本身也算是相当有感染力，看下来还是非常有感触的呢！如果你喜欢这种相对平缓又细腻的作品的话，这部作品还是很值得你花时间去看一看的呢！ 简单评分：8.4/10 ps：还是必须得赞叹PA在背景美术上的功力，能够单靠背景美术就吸引观众的制作公司说实话并不多啊！不过在高质量背景的衬托下，作品尤其到了后期的制作力，真的是比较捉襟见肘啊… ps2：本作的ED也是这个季度我很喜欢的ED，果然就是喜欢NAGI唱的歌啊！","permalink":"https://mondaycha.github.io/2020/03/09/309-1/","photos":["https://pic.downk.cc/item/5e72fc40e83c3a1e3a617bab.png"]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab0 实验报告","date":"2020/03/06","text":"OS Lab0实验报告一、实验思考题思考题0.1通过你的使用经验，简单分析 CLI Shell，GUI Shell 在你使用过程中的各自优劣（100 字以内） CLI Shell： 优点：操作符合计算机工作逻辑，有利于我们理解计算机的工作方式；大部分情况下比GUI效率高 缺点：不直观，上手有一定门槛 GUI Shell： 优点：易用，更加直观，所见即所得 缺点：消耗资源大，效率低 思考题0.2使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手） 具体实现的过程中思考下列问题：echo echo Shell Start 与 echo 'echo Shell Start'效果是否有区别；echo echo \\$c>file1 与 echo 'echo \\$c>file1' 效果是否有区别？ command文件： touch testecho 'echo Shell Start...' > testecho 'echo set a = 1' >> testecho 'a=1' >> testecho 'echo set b = 2' >> testecho 'b=2' >> testecho 'echo set c = a+b' >> testecho 'c=$[$a+$b]' >> testecho 'echo c = $c' >> testecho 'echo save c to ./file1' >> testecho 'echo $c>file1' >> testecho 'echo save b to ./file2' >> testecho 'echo $b>file2' >> testecho 'echo save a to ./file3' >> testecho 'echo $a>file3' >> testecho 'echo save file1 file2 file3 to file4' >> testecho 'cat file1>file4' >> testecho 'cat file2>>file4' >> testecho 'cat file3>>file4' >> testecho 'echo save file4 to ./result' >> testecho 'cat file4>>result' >> test result文件： 321 效果是否有区别： echo echo Shell Start 与 echo 'echo Shell Start'效果没有区别，均在Shell中打印echo Shell Start内容。 $ echo echo Shell Startecho Shell Start$ echo 'echo Shell Start'echo Shell Start echo echo \\$c>file1 与 echo 'echo \\$c>file1' 效果有区别：前者将echo $c重定向至file1，后者在Shell中打印echo \\$c>file1内容。 $ cat file13$ echo echo \\$c>file1$ cat file1echo $c$ echo 'echo \\$c>file1'echo \\$c>file1 思考题0.3仔细看看这张图，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？ git add // add the filegit add // stage the filegit commit // commit 思考题0.4深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？ 正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了git rm printf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？ 处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被git commit指令提交到版本库？ (1)帮小明把代码文件恢复： git checkout -- printf.c (2)弥补小红的过错： git reset HEAD printf.cgit checkout -- printf.c (3)删除暂存区文件： git rm --cached Tucao.txt 思考题0.5思考下面四个描述，你觉得哪些正确，哪些错误，请给出你参考的资料或实验证据。 克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。 错误。git clone 命令默认克隆master分支。 如果要克隆子分支可以使用git clone -b 命令。 克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。 正确。克隆出的工作区执行以上操作均是对本地版本库操作，需要用git push命令访问修改远程版本库。 克隆时只有远程版本库HEAD指向的分支被克隆。 正确。证据同(1)。 克隆后工作区的默认分支处于master分支。 正确。证据同(1)。 二、实验难点图示不传图了…… 三、体会与感想难度评价：★★☆☆☆ 花费时间：平台时间3h，查阅资料等5h左右 体会和感想： Lab0要求我们了解实验环境，熟悉Linux 操作系统（Ubuntu），了解控制终端，掌握一些常用工具并能够脱离可视化界面进行工作。 虽然“本章节难度非常低”，但在进行实验时我还是遇到了不少阻力——对命令行界面不熟悉、编写Shell脚本时不清楚步骤的内涵、在使用Vim时忍不住“Ctrl+S”却阻断输入……要学习与熟悉的还有很多。","permalink":"https://mondaycha.github.io/2020/03/06/304-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"如何获取更多Homework2性能分？","date":"2020/03/05","text":"如何获取更多Homework2性能分？为了获得更多的性能分，个人目前想到了以下注意点： Homework2与Homework1还是有不少相似之处的，因此在上次作业中的这些性能提升点，此次依然有效—— 表达式之间不含空格 如果存在正项，则表达式以正项为首项（且省略） 合并同类项 函数指数部分为0时不输出 非常数项：系数为1时不输出，系数为-1时仅保留负号 指数为1时不输出 0项不输出 而也有一些此次作业中新出现的抢分点： x**2以x*x形式输出 $sin^2(x)+cos^2(x)=1$ $sin^2(x)-cos^2(x)=1-2cos^2(x)$ 其中三角函数的化简较为复杂。 前者，我们注意到，对于形如$$ax^isin^j(x)cos^k(x)$$的项，能够以此规则化简的只有两种形式——$$ax^isin^{j+2}(x)cos^{k-2}(x)$$ $$ax^isin^{j-2}(x)*cos^{k+2}(x)$$ 化简后两项合并为——$$2ax^isin^{j-2}(x)cos^{k-2}(x)$$因此我们可以遍历容器并检查邻项是否存在，从而化简；而后者，在j=2|k=2时是肯定可以提升性能分的，方法与$sin^2(x)+cos^2(x)=1$的类似。 当然，个人觉得除非针对后两点构造数据，其出现的机率并不大，是否要为了性能分牺牲性能也是一个问题。 也求有想法的大佬交流下更好的方法与隐藏的内卷点(～￣▽￣)～ 为了获得更多的性能分，个人目前想到了以下注意点： Homework2与Homework1还是有不少相似之处的，因此在上次作业中的这些性能提升点，此次依然有效—— 表达式之间不含空格 如果存在正项，则表达式以正项为首项（且省略） 合并同类项 函数指数部分为0时不输出 非常数项：系数为1时不输出，系数为-1时仅保留负号 指数为1时不输出 0项不输出 而也有一些此次作业中新出现的抢分点： x**2以x*x形式输出 $sin^2(x)+cos^2(x)=1$ $sin^2(x)-cos^2(x)=1-2 cos^2(x)$ 其中三角函数的化简较为复杂。 前者，我们注意到，对于形如$a*x^i*sin^j(x)*cos^k(x) $的项，能够以此规则化简的只有两种形式—— $$a*x^i*sin^{j+2}(x)*cos^{k-2}(x)$$ $$a*x^i*sin^{j-2}(x)*cos^{k+2}(x)$$ 化简后两项合并为——$2*a*x^i*sin^{j-2}(x)*cos^{k-2}(x)$ 因此我们可以遍历容器并检查邻项是否存在，从而化简；而后者，在j=2|k=2时是肯定可以提升性能分的，方法与$sin^2(x)+cos^2(x)=1$的类似。 当然，个人觉得除非针对后两点构造数据，其出现的机率并不大，是否要为了性能分牺牲性能也是一个问题。 也求有想法的大佬交流下更好的方法与隐藏的内卷点(～￣▽￣)～ 既然无法贪心，只好搜索。 dfs，每次找到可合并的两个项去合并，然后回溯，不断记录最短答案，其中，两个项合并的次数(即合并之后的系数)要满足至少要用完其中一个项。 改完dfs发现要T（爆栈），就把每次dfs前的答案扔进set判重，即记忆化。 合并的话一开始只考虑了sin(x)2+cos(x)2=1然后用1−sin(x)2=cos(x)2以拆分常数项 和不含sin(x)sin(x)或cos(x)cos(x)的项来体现。后来发现速度很快但效果不好。 在队友丁总对我的指导下，我把1−sin(x)2=cos(x)2放进了dfs，成为合并两个项的新选择。 关于极端数据爆栈，卡住dfs次数和程序运行时间即可。最终性能分满分。 正常随机数据或项数不多的数据可以随便跑完，评论区里面的数据应该都能搜完。 欢迎大佬们批评指正，本数学弱鸡，码力选手只能想到这种暴力做法，写了快10k的优化类，累死。","permalink":"https://mondaycha.github.io/2020/03/05/305-1/","photos":[]},{"tags":[{"name":"推送","slug":"推送","permalink":"https://mondaycha.github.io/tags/%E6%8E%A8%E9%80%81/"}],"categories":[{"name":"写作","slug":"写作","permalink":"https://mondaycha.github.io/categories/%E5%86%99%E4%BD%9C/"}],"title":"宅家学习小窍门，你get到了吗？","date":"2020/03/04","text":"宅家学习小窍门，你get到了吗？转眼之间 BUAAers的在家学习时长已经接近两周 这段时间你是否掌握了新的学习方法？ 又有哪些小技巧有助于提高效率？ 今天就来一探究竟！ 窍门1：倍速的正确打开方式比起在教室上课，宅家学习主要以视频网课为载体，也有回放、倍速等功能。然而在倍速的时候就会发现，大部分课程所用的“腾讯课堂”电脑客户端在倍速后就不能准确记录学习进度，即使视频已经看完，进度条依然未满—— 解决方式是可以换用“腾讯课堂”移动端App来观看视频，这样学习进度就可以准确记录；也可以在初次学习后再播放一次视频，这样进度就会完成了。 当然，在使用倍速等功能时要结合自己的知识掌握情况，也可以在讨论时间与老师同学多多交流。 窍门2：用Snipaste做好摘录针对目前的视频授课的方式，不少课堂都会布置课后练习，那么如何在观看网课的同时抓住重点，做好笔记呢？这里推荐一款小工具——Snipaste。 Snipaste是一款安全无广告的免费软件，名字拆分开来即「截图+贴图」。软件的核心用法很简单，下载并打开 Snipaste，按下 F1 来开始截图，再按 F3，截图就在桌面置顶显示了。 而在看网课时，你可以用它快速保留视频上的重点，并在结束之后做一个整理。 此外，你还可以配合剪贴板工具Ditto使用，将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明、标记等。有了它，就算没有多屏协同，也不需要反复打开窗口比对信息，效率更是蹭蹭提升！ 窍门3：免费好用的OCR识别对于老师没有提供课程PPT，而我们又希望保留电子版笔记的情况，这个时候可能就要用OCR工具识别网课中的文字，然而市面上大多准确率高的识别类App（如扫描全能王、白描等）都有一定程度的收费。 对此，常用的社交工具微信与QQ都有相关功能，可以快速提取图片中的文字并导出。 最新版QQ可以在打开图片后选择“提取图中文字”选项，之后通过右上角小箭头转发到聊天窗口—— 如果你是一枚TIM党，也可以使用微信小程序“百度AI体验中心”，功能更加丰富，同样可以提取文字—— 窍门4：优雅地记住上课时间从“宿舍→食堂→教学楼”到“卧室→餐桌→书房”的三点一线，宅家学习足不出户便可遨游血海，却也增加了忘记上课的风险。此时，一份能提醒你上课时间的Todo清单就显得很有必要。 为此小编的朋友们也各显神通——QQ邮箱记事本提醒、Outlook日程提醒……这里就介绍一种用日历制作课程表的方式。只要设定以一周为周期的日程，标记好提醒时间，就不用担心错过课程。 以上就是小编这两周宅家学习的一些体会，你又在这段时间get到了哪些有趣的窍门？欢迎在下方评论区交流！","permalink":"https://mondaycha.github.io/2020/03/04/304-2/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS 实验报告 题干","date":"2020/03/03","text":"一、实验思考题 请认真针对实验指导书中本次实验思考题进行作答。实验思考都是一些半开放性的问题，希望你能将自己对于实验思考题的回答与见解尽量描述清楚，如果思考中强调了结合代码请一定要与源码结合。 二、实验难点图示 对于本次实验中你认为比较难的地方，用示意图、流程图或思维导图的方式来尽量表述清楚。 三、体会与感想 对于本次实验，给出你自己的难度评价，并如实记录你在这次实验上花费的时间，写出完成此次实验的体会和感想。 四、【可选】指导书反馈 我们的实验指导书还有许多问题，某些地方缺乏流畅性与简洁性，也有可能部分地方的理解是错的。如果你觉得哪里可以改进，希望积极提出，并给出修正的意见。 五、【可选】残留难点 在本次实验中你有哪些地方还很模糊，希望可以写出来与大家一起交流探讨。","permalink":"https://mondaycha.github.io/2020/03/03/303-1/","photos":[]},{"tags":[{"name":"OS","slug":"OS","permalink":"https://mondaycha.github.io/tags/OS/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OS Lab0","date":"2020/03/01","text":"练习0.1在 bash 中分别输入 echo “Hello Ubuntu”bash –versionls 三条命令，简单思考其回显结果 思考0.1通过你的使用经验，简单分析 CLI Shell，GUI Shell 在你使用过程中的各自优劣（100 字以内） 练习 0.2执行如下命令,并查看结果 echo firstecho second > output.txtecho third > output.txtecho forth > > output.txt ctags，很好用的小工具 (若实验环境中tree命令无效，输入sudo apt-get install tree命令安装，后面locate、tmux等同理) 练习0.3在/home/17xxxxxx_2019_jac/learnGit（已init）目录下创建一个名为README.txt的文件。这时使用 git status > Untracked.txt 。 在 README.txt 文件中随便写点什么，然后使用刚刚学到的 add 命令，再使用 git status > Stage.txt 。 之后使用上面学到的 Git 提交有关的知识把 README.txt 提交，并在提交说明里写入自己的学号。 使用 cat Untracked.txt 和 cat Stage.txt，对比一下两次的结果，体会一下README.txt 两次所处位置的不同。 修改 README.txt 文件，再使用 git status > Modified.txt 。 使用 cat Modified.txt ，观察它和第一次 add 之前的 status 一样吗，思考一 下为什么？ 思考题 0.2使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手） 具体实现的过程中思考下列问题：echo echo Shell Start 与 echo ‘echo Shell Start’效果是否有区别 echo echo $c>file1 与 echo ‘echo $c>file1’ 效果是否有区别 思考题 0.3仔细看看这张图，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？ 思考题0.4深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？ 正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了git rm printf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？ 处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被git commit指令提交到版本库？ 练习0.4找到我们在/home/17xxxxxx_2019_jac/下刚刚创建的README.txt，没有的话就新建一个。 在文件里加入Testing 1，add，commit，提交说明写 1。 模仿上述做法，把1分别改为 2 和 3，再提交两次。 使用 git log命令查看一下提交日志，看是否已经有三次提交了？记下提交说明为 3 的哈希值1。 开动时光机！使用 git reset –hard HEAD^ ，现在再使用git log，看看什么没了？ 找到提交说明为1的哈希值，使用 git reset –hard ，再使用git log，看看什么没了？ 现在我们已经回到过去了，为了再次回到未来，使用 git reset –hard ，再使用git log，我胡汉三又回来了！ 思考题0.5思考下面四个描述，你觉得哪些正确，哪些错误，请给出你参考的资料或实验证据。 克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。 克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。 克隆时只有远程版本库HEAD指向的分支被克隆。 克隆后工作区的默认分支处于master分支。 练习0.5仔细回顾一下上面这些指令，然后完成下面的任务 在 /home/17xxxxxx_2019_jac/17xxxxxx-lab下新建分支，名字为Test 切换到Test分支，添加一份readme.txt，内容写入自己的学号 将文件提交到本地版本库，然后建立相应的远程分支。","permalink":"https://mondaycha.github.io/2020/03/01/302-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"面向过程的设计，和面向对象的设计异同点到底在哪？","date":"2020/03/01","text":"抛砖引玉 不同点： 面向过程的设计以函数为核心，接近问题处理过程；面向对象的设计以类为核心，将不同类的属性区分开来（比如students的学分属性与course的学分属性），符合人类认知规律。 面向对象的设计有继承、多态的特性，低耦合高内聚，便于添加需求，在处理大型项目时也有着更好的可读性。 相同点： 在设计过程中，为了简化复杂度，面向过程与面向对象都存在封装性。 都是用来解决问题的程序思想","permalink":"https://mondaycha.github.io/2020/03/01/302-2/","photos":[]},{"tags":[{"name":"马克思主义","slug":"马克思主义","permalink":"https://mondaycha.github.io/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"对马克思主义的理解","date":"2020/02/23","text":"在参加本学期马克思主义基本原理概论课程之前，我对于马克思主义的理解主要是这样的： ① 马克思主义不是“马克思的主义”。“马克思主义”是由马克思、恩格斯创立，以及广义上由后续社会主义的践行者们一同发展与完善的理论体系。因此，并非所有马克思本人的学说都是马克思主义。 ② 马克思主义包含辩证唯物主义认知与科学社会主义理论。其中唯物主义哲学观是与当时科学发现相结合的成果，意味着人类对于自然的认知进入了一个全新的阶段；科学社会主义理论则成为了工人阶级捍卫自身权益的有力武器，引导着俄国十月革命以及中国共产党的发展。 ③ 马克思主义对于人类的意义非常重大。它有着对于资本主义弊端切中肯綮的剖析，也让社会主义从“空想”变为“现实”。在马克思主义的指导下，资本主义与社会主义都不断完善与发展，人类文明也在其影响下向前迈进。 ④ 马克思主义具有蓬勃的生命力。马克思主义不是一成不变的，是结合具体国情，在辩证中不断发展的。因此，马克思主义的生命力将长期伴随人类文明，在螺旋式的上升中与人类共同进步。 以上就是我对马克思主义的粗浅理解，希望在上完本课程之后能将有更深入的理解。","permalink":"https://mondaycha.github.io/2020/02/23/226-1/","photos":[]},{"tags":[{"name":"影评","slug":"影评","permalink":"https://mondaycha.github.io/tags/%E5%BD%B1%E8%AF%84/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"《一堂好课》观后感","date":"2020/02/23","text":"《一堂好课》观后感今天20:30，我观看了由戚发轫院士主讲，康辉担任班主任的综艺节目《一堂好课》。在课上，戚发轫院士讲述了自己的亲身经历，讲述了今年将要探索火星的规划，讲述了中国作为航天大国面临的机遇与挑战。期间流露出的北航人的航天精神令我深深地被触动了。 而课间的航天员助教与小朋友宇航员的互动也很有趣，航天员乐观灿烂的回答，也是他们坚守使命勇往直前的真实写照。 几十亿年前的一次意外孕育出生命的奇迹，相信未来人类也将跨出银河之摇篮，遨游星海！","permalink":"https://mondaycha.github.io/2020/02/23/223-1/","photos":[]},{"tags":[{"name":"测评","slug":"测评","permalink":"https://mondaycha.github.io/tags/%E6%B5%8B%E8%AF%84/"},{"name":"知乎","slug":"知乎","permalink":"https://mondaycha.github.io/tags/%E7%9F%A5%E4%B9%8E/"}],"categories":[{"name":"测评","slug":"测评","permalink":"https://mondaycha.github.io/categories/%E6%B5%8B%E8%AF%84/"}],"title":"Fotor懒设计","date":"2020/02/20","text":"关于今年的全面在家自学，我和我的舍友都表示十分心痛。上学期末宿舍合资购入了一台国行版本的Switch游戏机，当时想着反正假期也就一个多月，就把Switch扔在宿舍了…… 结果现在只能望着连不上主机的健身环而长叹了…… 当然，特殊时期，宅家就是做贡献。已经连续学习数日的码呆就与各位知友分享一下自己体验过的、感觉还不错的学习方法/网课资源/辅助工具。 如果你有好的推荐，也欢迎在评论区补充~ ①课程学习篇1. 学堂在线学堂在线是清华大学发起的精品中文慕课平台，为广大学习者提供来自清华、北大、斯坦福、MIT 等知名高校创业、经管、语言、计算机等各类 1000 余门免费课程。 为什么推荐它……因为这是来自咱大学班主任的安利orz。 2. 腾讯课堂腾讯课堂是腾讯推出的专业在线教育平台，个人觉得更偏向职业教育一些，学到的东西都很实用。内部也有很多免费公开课，另外也有一些高校特殊时期将通过这个平台直播授课…… 而之前我也跟着上面的免费教程学习过板绘技巧，相比x铅笔等平台，能获取的资源还是很丰富的。 3. 中国大学MOOC中国大学MOOC(慕课) 是国内优质的中文MOOC学习平台，由爱课程网携手网易云课堂打造。 平台拥有包括985高校在内提供的千余门课程，以及认证国家精品课，质量很高。 这个高校学生应该都很熟悉，我还有一门学分课是在上面上的，不得不说自带2倍速真是感动人心！ 如果是不带倍速的在线授课平台也不用慌，可以试试一款小软件“encourage my speed”，对大部分网页视频资源都有效果！ 4. Bilibili前面三个大家想必都知道，最后这个就更不用说了。事实上B站也有不少优质的课程资源就是up主从上面的平台搬运过来的。 而在B站看的一大好处就是有弹幕互动，气氛也变得更加活♂泼。 No.2：办公技巧篇1. 优品PPT课程展示、工作汇报等都会用到一些Office操作，而趁着寒假提升一下PPT技巧也是一项不错的选择。 优品PPT就是我个人很常用的PPT模板网站，所有的模板都是免费的，避免了“好看的模板都要收费，能用的免费万里挑一”的尴尬局面。 在制作过程中更重要的也还是内容，但简洁大方的PPT对表达也会增色不少。 2. Fotor懒设计对于不会使用PS/AI又需要做点简单的设计的人来说，像Fotor这样的在线设计工具显然是大救星。不需要自己准备，平台已经有大量模板和素材，可以帮你快速做出设计成品。 码呆也在学生组织的宣传部门工作，为了偷懒经常套用下Fotor的模板然后修修补补……另外也可以使用懒设计的微信小程序，在手机上就可以快速做出海报、宣传单、公众号头图。并且你可以把它认为是简配版的PS，有了网站的操作经历，也更容易入门平面设计。 3. doyoudo如果说你不满足于简配版的Fotor，想要进一步学习PS/AI等软件的操作的话，那么可以试试doyoudo！ 最开始了解doyoudo是在其bilibili的官方账号，而之后体验了网站也感觉非常值得推荐！ doyoudo网站有丰富的设计类软件教学资源，当然如果你觉得无从下手，也可以参考他们在B站的频道上的精选内容。 No.3 技能知识篇1. 廖雪峰的官方网站廖雪峰的编程自学网站是出名的免费又良心，这个寒假我就在用它学习Git和Java，为下学期的面向对象圣杯战争课程做准备（然而寒假之前大部分时间拿去看小说，实在是太惭愧了）。 美中不足的是广告有点多，搭配uBlock Origin等广告拦截插件食用更佳。 2. B站摄影教程Vlog这两年也挺火的，我平时也会在B站学习一些视频拍摄技巧。这里墙裂安利up主 @8K8K 分享的油管摄影教程。 双语字幕+难词详解还可以让你在看视频之余学学英语。 No.4 好用小软件除了网站资源，为电脑装些好用的小工具对于假期自学也是有很大的帮助滴，这里也分享下码呆常用的4款—— ① Snipaste对于经常需要用电脑的同学来说，电脑屏幕自然是越多越好，所以我周围也有不少同学组了双屏，方便码代码+查资料，比如这就是我舍友参考了知乎回答后的桌面—— 而如果没有双屏的话……你也可以试试Snipaste的贴图功能。 Snipaste是一款安全无广告的免费软件，名字拆分开来即「截图+贴图」。软件的核心用法很简单，下载并打开 Snipaste，按下 F1 来开始截图，再按 F3，截图就在桌面置顶显示了。 此外，你还可以将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明、标记等。有了它，就算没有多屏协同，也不需要反复打开窗口比对信息，效率更是蹭蹭提升！ ② Everything如果知友常常阅读软件推荐类文章，那一定对Everything并不陌生——因为它真的是太好用了！所以我也不能免俗，再安利一下。 “Everything” 是 Windows 上的一款搜索引擎，它能够基于文件名快速定文件和文件夹位置，和自带搜索相比就像飞机和马车。 Everything就可以帮助你快速查找平时的课程资料，对于NTFS格式的硬盘，只需要1秒就能建立约120000文件的索引，借助正则表达式等搜索语法，可以快速找到你需要的文件。 不过如果遇到x信万恶的“此文件已过期”提示，即使是Everything也无能为力，最好还是在平时就养成文件保存与同步的好习惯…… ③ Adobe Acrobat对于需要阅读大量PDF文件的情况，Adobe Acrobat绝对是称手的好工具。 Adobe Acrobat 是由Adobe公司开发的一款PDF（Portable Document Format，便携式文档格式）编辑软件。借助它可以以PDF格式制作和保存你的文档 ，以便于浏览和打印，或使用更高级的功能。PDF转Word？PDF标记？都不再是问题！ 缺点是正版比较贵，不过不少学校都有免费的Adobe全家桶，真的好用。 ④ Enounce MySpeed这个上面就提到过了，Enounce MySpeed是一款小巧实用的网络视频播放控制工具，支持加快或减慢网页内的视频播放速度，快进最快可以5倍速度播放，慢放最慢可以减慢至1/3。 如果有看网课的需求，又觉得网站自带的倍速工具还不够用，那就可以试试Enounce MySpeed。 最后：放松一下吧The Useless Web学习了那么久，何不来放松一下？The Useless Web 就是一个汇集了互联网上没什么信息价值的站点集合。搞笑图片、消遣游戏……一切皆有可能。 每一次点击「PLEASE」按钮，都会随机跳转到无聊的新世界！ （不过大部分时候加载速度堪比龟速……） 以上，祝大家都能利用好假期时间！我是码呆茶，我们下次再见~","permalink":"https://mondaycha.github.io/2020/02/20/220-1/","photos":[]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"},{"name":"吐槽","slug":"吐槽","permalink":"https://mondaycha.github.io/tags/%E5%90%90%E6%A7%BD/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"在异世界寻找实感绝对是做错了","date":"2020/02/16","text":"为什么辣鸡轻小说男主角标配阳痿？今天以二倍速的坚定决心看了《异世界魔王与召唤少女的奴隶魔术》这一部番剧。 怎么说，也没有让我觉得很“爽”（看《盾勇》的时候还被菲洛小天使治愈到了呢），福利镜头让人有些恶心…… 舍友XDD表示你为什么这么喜欢异世界题材，从今天开始恐怕就不用他说了…… 以上，Task6加油。","permalink":"https://mondaycha.github.io/2020/02/16/216-1/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://mondaycha.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"Happy Valentine's Day!","date":"2020/02/14","text":"窗外的雨一直下着 肚子有点饿 今天下午吃了什么来着 忘了","permalink":"https://mondaycha.github.io/2020/02/14/214-1/","photos":["https://pic.downk.cc/item/5e46786248b86553ee202ef3.png"]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"OO预习第三弹","date":"2020/02/13","text":"OO预习第三弹今天终于做完了Pre1的Task6，借助TreeSet类。 OO第三弹也出了，与IO/正则表达式等有关，明天继续加油。","permalink":"https://mondaycha.github.io/2020/02/13/213-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"Task5蒙圈中","date":"2020/02/12","text":"我需要明确一下接下来的时间规划。 上午：进一步了解Java类、继承、集合。 下午：纠结微信推送 晚上：争取通过Task6","permalink":"https://mondaycha.github.io/2020/02/12/211-1/","photos":[]},{"tags":[{"name":"推送","slug":"推送","permalink":"https://mondaycha.github.io/tags/%E6%8E%A8%E9%80%81/"}],"categories":[{"name":"写作","slug":"写作","permalink":"https://mondaycha.github.io/categories/%E5%86%99%E4%BD%9C/"}],"title":"我们无法一起学习……","date":"2020/02/12","text":"我们无法一起学习，但可以分散学习！ 假期余额渐渐减少，相信也有好多小伙伴陆续开启了自学模式。 ……安利下那些宝藏级的学习/工具网站~ 课程学习①学堂在线 清华大学发起的精品中文慕课平台，为广大学习者提供来自清华、北大、斯坦福、MIT 等知名高校创业、经管、语言、计算机等各类 1000 余门免费课程。 ②腾讯课堂 ③中国大学MOOC 联合国内众985、211高校，包括北京大学、浙江大学、南京大学等知名高校在内的近600所高校的精品公开课程，涵盖计算机、经管、工学、理学等十几个大类，如果受到语言学习障碍，Coursera无法满足你的要求，不妨来这里看看，足不出户，享受国内顶级的高校教学资源。 办公技巧④ 优品PPT ⑤Fotor懒设计 ⑥ 现实君工具箱 技能知识⑦ 廖雪峰 ⑧ B站摄影教程 ⑨ doyoudo 内容以设计软件为主，包括 Pr、C4D、AE、AU、Ai、PS 等。 彩蛋⑨useless web 这个是来自澳大利亚的程序猿发明的网站，里面收集了大量来自世界各地的「useless web」。点击一下「PLEASE」按钮，我们就能进入新世界！","permalink":"https://mondaycha.github.io/2020/02/12/212-1/","photos":[]},{"tags":[{"name":"OO","slug":"OO","permalink":"https://mondaycha.github.io/tags/OO/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"为圣杯战争的开始献上礼炮","date":"2020/02/10","text":"BUAA-OO从昨天开始，BUAA 2020年春季的面向对象课程就算是拉开帷幕了。 2月9日为 Github 和 Gitlab 配置不同的 SSH 参考资料： https://segmentfault.com/a/1190000009572470?_ea=1985120 2月10日为 Github 配置单独的 Git 用户名与邮箱 参考资料： https://www.cnblogs.com/itbsl/p/10469523.html","permalink":"https://mondaycha.github.io/2020/02/10/210-1/","photos":[]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://mondaycha.github.io/tags/Git/"},{"name":"廖雪峰","slug":"廖雪峰","permalink":"https://mondaycha.github.io/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"Git-Day3","date":"2020/02/09","text":"工作区和暂存区 工作区：在电脑下的工作目录 版本库：工作区下的隐藏目录.git 暂存区：stage(index) 引评论区 @九只蜗牛Leo 的例子： 感觉大家把简单问题复杂化了，看着头晕， Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库) 工作区>>>>暂存区>>>>仓库 git add把文件从工作区>>>>暂存区，git commit把文件从暂存区>>>>仓库， git diff查看工作区和暂存区差异， git diff –cached查看暂存区和仓库差异， git diff HEAD 查看工作区和仓库的差异， git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区， git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。 管理修改如果不使用git add添加到暂存区，那么就不会添加到commit中。 撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件从版本库中删除文件git rm 并且使用git commit进行提交操作 $ git rm test.txtrm 'test.txt'$ git commit -m \"remove test.txt\"[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt git checkout是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库ssh密钥的配置在研究HEXO的时候做过了，感动！ 添加远程库origin: Git远程库的名字 $ git push -u origin master 只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 我在学习Hexo的时候用的是https协议，而采用git协议的参考样例如下—— $ git clone git@github.com:michaelliao/gitskills.gitCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.","permalink":"https://mondaycha.github.io/2020/02/09/209-2/","photos":[]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"},{"name":"轻小说","slug":"轻小说","permalink":"https://mondaycha.github.io/tags/%E8%BD%BB%E5%B0%8F%E8%AF%B4/"}],"categories":[{"name":"资源","slug":"资源","permalink":"https://mondaycha.github.io/categories/%E8%B5%84%E6%BA%90/"}],"title":"『ePub资源』有时间谈恋爱不如去抽卡！02","date":"2020/02/09","text":"哇，这次终于准备好了“精排版”的第二册。 下载渠道： 链接：https://pan.baidu.com/s/1oBC-fIF3JKi1swqB23l8ag提取码：2333 嘿嘿，冲鸭！！！","permalink":"https://mondaycha.github.io/2020/02/09/209-1/","photos":["https://pic.downk.cc/item/5e3f5e1d2fb38b8c3c3ecf23.jpg"]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://mondaycha.github.io/tags/Git/"},{"name":"廖雪峰","slug":"廖雪峰","permalink":"https://mondaycha.github.io/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"Git-Day2","date":"2020/02/07","text":"从一次尝试说起今天试着把自己的祭祖代码提交到 Github 上，总结一下操作： 进入本地项目文件夹，右键“Git Bash Here” 输入git init，完成初始化 输入git add .，将当前目录下所有文件添加到仓库 输入git commit -m \"xxxx\"，提交修改 首次提交要git pull 一下，git pull origin master 将代码提交到GitHub上，git push -f origin master 这里，关于第六步，有两种办法： git push -u origin mastergit push -f origin master 后者是强制上传覆盖远程文件。 最后总算是提交成功了，附上仓库地址—— https://github.com/MondayCha/BUAA-CO-2019 床前明月光，疑似地上霜。举头望明月，低头思故乡。 床前明月光，疑似地上霜，举头望明月，低头思故乡。","permalink":"https://mondaycha.github.io/2020/02/07/207-2/","photos":[]},{"tags":[{"name":"吐槽","slug":"吐槽","permalink":"https://mondaycha.github.io/tags/%E5%90%90%E6%A7%BD/"}],"categories":[{"name":"摘录","slug":"摘录","permalink":"https://mondaycha.github.io/categories/%E6%91%98%E5%BD%95/"}],"title":"没有生产资料的我直到被现实毒打才回想起那份恐惧","date":"2020/02/07","text":"关于今天的我干了什么 早上10:00前打卡 怠惰，吃早饭，喝水，洗碗 下午，一边刷手游一边看番 之后，与译者取得联系，制作epub 吃晚饭，洗碗 在B站看半佛仙人 今日份的 Git 还没有学，之后需要补充一下。 关于接下来要做的文章摘录源地址：《你大可以尽情花钱，只要对人生毫不在乎》 仙人JUMP 微信号：xrtiaotiao 功能介绍：仙人可痒痒可跳跳了。 今天逛B站的时候看到了半佛的视频《买不起奢侈品就是穷人吗？不，是聪明人》，突然意识到自己这半年的消费有很多不理智的地方，所以摘录一部分在自己的博客里。 一些摘录 消费主义是什么？ 简单来说，任何把让你掏钱的事情描绘的别有一番意义的事情，都是消费主义的一种体现。 看清楚，不是说买东西就是消费主义，而是让你通过买东西，去获得一种虚无的快感，这叫做消费主义。 典型的消费主义特质，就是把消费与个人社会标签捆绑在一起，让你为个人标签支付更多的金钱。 我们绝大多数人，别管有钱没钱，其实获得收入的方式只有一种。 靠出卖自己的劳动力和时间赚钱，简称上班。 至于你在CBD吹空调还是在工地搬砖，都是上班，无非是高级上班和低级上班。 大家都是穷人。 只要你还在靠出卖自己的劳动力和时间获取收入，哪怕年薪百万是高级职业经理人，你依然是个穷人，别想着给自己贴什么高级标签，更别觉得那些所谓中产必买的东西对你有什么意义。 哪有什么中产，中产就是消费主义鼓吹出来的谎言。 实际上，轻奢才是收割当代年轻人和无知打工族的利器。 各种两百块的口红，千把块的化妆品，小几千的包包和衣服，价格谜一样的AJ，都属于轻奢的范畴。 就是这种有点贵，咬咬牙又能消费得起，消费之后只能吃泡面，但是拿出去还有点面子的东西。 奢侈品是有钱人拿来区分自己阶级的东西，轻奢级别的产品就是各类精神中产拿来区分自己和平民大众的东西。 都不是什么好东西。 那么问题来了，人活着总得消费，要省下钱必然要克制消费，怎么克制？ 既然我们对于自我的意志力存在判断不准的情况，那么很简单我们不去理会这种东西，我们直接衡量价格就行。 如果这个东西你不能百分百确认是高收益产品，那么只要他的价格超出了你月收入的15%，就砍掉没错。 所有没有实用价值，但是能让你获得精神满足的支出，那么只要价格超出了你月收入的5%，就砍掉没错。 每月给自己定一个KPI，存多少钱，然后一点点抠着达成，如果最终超过了目标，那么拿出超过目标的一小部分犒劳自己一下，没有任何问题。 而一阵大额消费透支信用卡之后，带来的只有空虚和负罪感。 互联网抹平了信息差，但又造成了心理落差。 以前我们都穷，身边人都那样，现在我们看到了真的有这么多富人过着这么爽快的生活，看到了这么多明星这么光鲜的日子。 所以就有落差。 之所以今天突然如此“鸡汤”，大概是因为还了花呗吧。","permalink":"https://mondaycha.github.io/2020/02/07/207-1/","photos":[]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://mondaycha.github.io/tags/Git/"},{"name":"廖雪峰","slug":"廖雪峰","permalink":"https://mondaycha.github.io/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://mondaycha.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"title":"Git-Day1","date":"2020/02/06","text":"创建版本库选择一个合适的地方，创建一个空目录： $ mkdir learngit$ cd learngit$ pwd 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add，注意，可反复多次使用，添加多个文件； 使用命令git commit -m，完成。 时光机穿梭要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。","permalink":"https://mondaycha.github.io/2020/02/06/206-1/","photos":[]},{"tags":[{"name":"新浪众测","slug":"新浪众测","permalink":"https://mondaycha.github.io/tags/%E6%96%B0%E6%B5%AA%E4%BC%97%E6%B5%8B/"},{"name":"耳机","slug":"耳机","permalink":"https://mondaycha.github.io/tags/%E8%80%B3%E6%9C%BA/"}],"categories":[{"name":"测评","slug":"测评","permalink":"https://mondaycha.github.io/categories/%E6%B5%8B%E8%AF%84/"}],"title":"轻若无物，质地有声 | JBL T280NC 降噪蓝牙耳机","date":"2020/02/05","text":"如果要给过去两年消费级音频产品的发展趋势做个总结的话，大概用两个词就足以概括——“TWS”（真无线）和“ANC”（主动降噪）。WF-1000XM3与AirPods Pro的推出，更宣告了“合二为一”的真无线降噪耳机元年的开启。 在这样的背景下，在2020年谈论颈挂式降噪耳机似乎已经有些过时——技术的进步让作为过渡的它沦为明日黄花；TWS与ANC二者可以兼得的事实更昭示着它那终将被抛弃的宿命……只不过，凡事都有例外—— 如果你常常苦恼于TWS耳机的丢失呢？ 如果你对音质与续航有着更多的需求呢？ 如果……存在一款佩戴体验优于TWS耳机的颈挂式降噪耳机呢？ 而这，就是我们今天的主角——JBL T280NC入耳式无线降噪蓝牙耳机——登场的时刻：30g的轻盈机身/10h的降噪续航与2h快充/ANC与立体声通话……如果这些还不够吸引你的话，那么就接着往下看吧，以下为本文目录—— 开箱：听说要有点仪式感？ 外观：可低调，亦可潮流 佩戴：无感是最好的感受 体验：长板不长，短板不短 总结：可降噪，亦轻盈 ▎开箱：听说要有点仪式感？首先自然是要感谢 @新浪众测 给的这次众测机会！在体验JBL T280NC之前，我用过的上一款颈挂式降噪耳机还是SONY的WI-1000X，之后则完全被TWS耳机的方便与轻巧的优点所俘获…… 而这次体验的T280NC是JBL旗下颈挂式降噪耳机产品线于去年12月发布的新品。JBL作为老牌音频领域厂商，产品由哈曼声音工程师精准调校，不管是音质还是售后都有着不错的保障。 ▼都说开箱要有仪式感，先来看看产品的外包装。设计上和道具书有几分相似，橙/黑/白的拼接颇具活力，侧面“DARE TO LISTEN!”的Slogan也很契合潮流。 ▼背面则是产品主要卖点介绍与清单，可以看到还自带了收纳包。IPX4级别的防水也意味着你可以用它兼任运动耳机使用。 ▼撕开右侧的封条，如翻开书籍一般揭开盖子。左边的Live现场让我不禁联想到网易云的默认曲图，不过实际出处并未详细考证；JBL T280NC则静静躺在塑料垫中，等待着由用户来开启那音乐世界。 ▼内部配件一览，附带的东西还算中规中矩：T280NC耳机本体、红色充电线、S/L规格替换硅胶耳塞、耳机包以及各式说明书。 ▎外观：可低调，亦可潮流JBL T280NC有激情红/梦幻蓝/寒光灰三种配色，这次我拿到的是梦幻蓝版本。配色挑选上个人倾向于寒光灰一些，毕竟黑白灰永远是时尚的主旋律；而激情红的红黑撞色设计则充满潮流之感，就看个人喜好了。 ▼耳机的各按键与接口，线控位于左侧，右侧则对称设计，印有“JBL”的Logo。一体化的设计也带来更好的防水性能，IPX4级防水应对日常跑步等都毫无压力。不过机身上没有NFC标记，不带NFC直连是一个小遗憾。 另外还有一点需要吐槽的是——9102年发布的耳机还在采用Micro-USB接口？？？并且参看说明，不能使用电压＞5V，电流＞1.2A的快速充电器为耳机充电，否则可能造成损坏……emmm，看在我的Kindle也用的Micro-USB接口的份上，这次就饶过你罢。 ▼回到耳机本体，耳机线材是扁扁的“面条带”式，一大优点就是不容易打结，放在收纳包里也很轻松。具体来说线材是中间黑两侧蓝的“夹心饼干”式，蓝黑搭配不像红黑对撞那么富有张力，却为JBL T280NC耳机带去了几分过渡的渐变美。 ▼耳机腔体特写，腔体与线材连接处有“L”“R”的标识，实际使用过程中我更习惯借助线控位置判断佩戴方式。 ▼浅蓝色硅胶耳塞带有鲨鱼鳍状的固定设计，JBL T280NC的替换耳塞有S/M/L三种规格，默认配置的是中号M规格。需要注意的是耳塞形状较为特殊，与一般的耳塞并不通用，如果不慎丢失就有些麻烦。 好在一方面JBL T280NC的耳塞与耳机腔体联系较为紧密，除非从特定角度施加拉力，否则很难扯下来；另一方面耳塞与鲨鱼鳍一体化的设计也让JBL T280NC有着很舒适的佩戴感受，这一点在之后的佩戴感受部分会再做进一步说明。 ▼颈挂式耳机的设计初衷就是通过将重量分担在脖颈部以减轻耳朵承重，JBL T280NC自然也附带了磁吸耳机单元的功能，在暂时不需要使用时可以自动吸附住，方便日常出行。我感受了一下吸力，磁铁的吸附性较强，日常运动还是不容易散开的。 ▼将耳机放入收纳包中，收纳包对耳机的保护效果不是很大，内部有细绒布起一定的防刮花作用。个人觉得以JBL T280NC的轻量化设计，收纳袋可以设计得更小一些，方便直接揣入口袋里；或者设计为硬壳式，为耳机提供更多保护。 ▎佩戴：无感是最好的感受当我们在谈论耳机的佩戴感受时，我们在谈论什么？这首先要从耳机的分类说起：从耳机与播放源的连接方式来说，可以分为有线耳机与无线耳机；从佩戴方式来说，大致可以分为头戴式、耳塞式、入耳式、挂耳式等。 这些分类主要是根据发声单元的固定方式而定的，而对于主动降噪无线耳机来说，最主流的就是头戴式、分体入耳式、颈挂入耳式。头戴式使用类似于夹子的形式保持稳定，影响佩戴感受的因素常常可以总结为“闷不闷”“加不夹头”“重不重”；分体入耳式为了固定会尽可能贴合耳道，影响佩戴感受的因素常常可以总结为“胀不胀”“重不重”；而颈挂入耳式与人体接触的部位是外耳以及脖颈部，影响佩戴感受的因素常常可以总结为“沉不沉”“黏不黏”…… 相比头戴式，颈挂式更加低调；相比分体式，则减小了丢失的风险。虽然分体式已然是大势所趋，但一款佩戴舒适的颈挂式在2020年的当下还是很有竞争力的。 那么谈到舒适性，JBL T280NC又表现如何呢？我之前用过的WI-1000X在佩戴上只能说是差强人意，且不谈掉漆鼓包的品控问题，较重的金属项圈虽然有着很好的质感，但实际佩戴时总会让你感觉到它的存在。 JBL T280NC的佩戴体验则着实让我感到惊喜——30g的质量在一众降噪颈挂式耳机里就像一股清流。如果穿的是带领子的衣服，脖颈处基本没有任何感受；直接接触皮肤的情况下，硅胶项圈贴合脖颈的接触面大概在后半部，除了刚戴上时有几分冰凉，一段时间之后，很快就能沉浸到自己的世界之中。 而耳朵的感受来说——刚刚好，我也用过连线式的WI-SP600N蓝牙运动降噪耳机，过硬的鲨鱼鳍虽然保证了运动时脱落的可能性极小，但佩戴简直就是对外耳的折磨。JBL T280NC的感受则大不相同，鲨鱼鳍在固定住耳机的同时，基本不会对外耳带来别的负担。如果你是初次佩戴的话，我也建议你将三副耳塞都依次尝试一下，选择最适合自己的那一副，从而获得更好的佩戴体验。 那么，运动的时侯表现如何呢？JBL T280NC支持IPX4级别防水，卖点宣传里也提到了“运动”“跑步”等。由于这段时期较为特殊，码呆就不出去溜达了，在家跟着T25视频做训练。在做动作的过程中，对于俯身、开合跳等大幅度动作，JBL T280NC都固定地较稳，也没有异物感等。 对于任一款耳机来说，佩戴都是最为关键的因素——毕竟佩戴不舒服，音质云云再好也是白搭。而 JBL T280NC或许就达到了能让专心的你感受不到它的存在的境界，这一点值得表扬~ ▎体验：长板不长，短板不短佩戴这一关算是让人放心了，接下来就从连接与操作、连接稳定性、音质主观评价、通话质量、降噪效果等方面来谈谈耳机的综合体验。 ▢ 连接与操作 JBL T280NC开机时有类似于汽车引擎发动的低音炮，以及“ANC ON”的提示（开机时默认进入ANC主动降噪模式）；关机时则是一阵稍短促的低音，概括来说就是很带感啦，不愧“纯正低频音效”之名。 耳机除了音量加减、接听挂断通话等基本操作以外，还支持ANC/AA/无效果三种模式切换：在ANC模式下会启动数字智能降噪，通过置于耳机墙体的反馈降噪麦克风生成抵消信号，实现数字降噪；AA（Ambient Aware环境感知）则会放大外部的环境音，增强收音效果。在切换模式时会有英文语音提示，个人建议还是出中文语音版本的，对国人更加友好。 蓝牙版本为5.0，给个大大的好评。设备连接上，我依次连接了Android手机设备（魅族 Pro7）、iOS手机设备（iPhone 7）、iOS平板设备（iPad Pro 10.5）、笔记本电脑设备（Lenovo Y7000），蓝牙连接都很简单，速度也很快。 ①Android手机设备上，支持五节电量显示，连接后使用音乐软件测试，可以通过线控进行切歌、暂停与播放等操作。不过无法通过耳机调节系统音量，算是一个小遗憾。 ②iOS手机设备上，支持电量显示，连接后使用海贝音乐软件测试，可以通过线控进行切歌、暂停与播放等操作，也可以通过耳机调节系统音量。 ③iOS平板设备上，支持电量百分比的快捷显示： 使用视频软件播放MV，可以通过耳机调节系统音量、进行暂停/播放操作。 再来一把对声画同步要求较高的音游，JBL T280NC同样感觉不出延迟，游戏时可以跟上节奏与鼓点。 ④最后就是笔记本了，在Windows设置中心找到蓝牙后搜索并配对，连接速度同样很快。 使用在线网页播放MV，可以通过耳机调节系统音量（每次约6-7点）、进行暂停/播放操作。 总的来说，对于全平台，JBL T280NC都有着很稳当的体验。多设备切换时，只要断开设备A并打开设备B蓝牙，耳机就会自动连接。不过有一处不足——耳机在配对成功时会有短铃声提示，但断开连接时则没有。 ▢ 连接稳定性 连接稳定性上，在距离8m之内都较为稳定，8m之外就可能会出现断连、无声等情况。 而对于在日常使用过程中的大部分场景，基本不会有断连，蓝牙5.0的连接优势还是很明显的。 ▢ 音质主观评价 JBL T280NC主打低频，虽然不支持LDAC，但也有自家“JBL PureBass”音质传输加成。采用10mm动圈驱动单元，16Ω的阻抗，5Hz-22kHz的频响范围以及哈曼声音工程师精准调校，这些都意味着JBL在这款耳机的音质上下足了功夫。 实际体验上，蓝牙传输的稳定性与延迟已在上文种说明，而最为主观的音质上，个人觉得低频的加强更适合运动时的“动次打次”。用海贝音乐试着播放flac格式的蔡琴的《渡口》，也播放《四叠半神话大系》的ED曲，感觉后者虽然不是无损云云，但给我的感触颇深。 开场鼓点的氛围渲染更加猛烈，空灵的人声反而有一些被掩盖之意，却也带来了全新的体验与感受，身体也不禁随着电音的节奏律动——都说到这份上了，低频确实很足嗷！ 而耳机本身的解析度也不在话下，人声与背景乐都有着很好的分离。音质表现整体还是不错的，如果喜欢低音风格，说不定它就是你的菜。 ▢ 通话质量 通过iOS手机设备接听电话，对面反馈人声清晰，背景音乐影响不大，不需要调整耳机就能很好的收音。 JBL T280NC内置双重回音消除技术麦克风，在通话这一点上做的确实不错。 ▢ 降噪效果 最后一点就是JBL T280NC的降噪效果了。坦白说，个人觉得降噪能力上JBL T280NC还不够出色，这也是我将体验一节命名为“长板不长，短板不短”的原因——除了让人惊艳的轻量化，这个“木桶”的表现很平均。 关于降噪，JBL T280NC有ANC/AA/无效果三种模式。耳机初始启动自动进入ANC模式，这一过程会通过置于耳机墙体的反馈降噪麦克风生成抵消信号，实现数字降噪。当然，降噪并不意味着就此与外界隔绝，一方面耳机不可避免会产生一些底噪，另一方面对于高频人声等都不能做到有效的消除。 在底噪方面，JBL T280NC的底噪并不大，在最小音量下播放音乐即可消除；而降噪效果上，码呆此时写文时窗外正下着雨，最小音量下播放音乐后，无论是雨拍打栏杆声或是窗外偶尔的车鸣声，都就此隔绝。 虽然如此，但体验过其他好点的降噪耳机就会感觉出JBL T280NC的消除能力相对弱些，也不带降噪等级调节。不过在700元左右的价位，JBL T280NC还是能站住脚跟的。 而Ambient Aware环境感知模式的体验则并不良好，在安静的室内，增强之后的收音都会让人感到一些不适，在嘈杂的室外更不用说……所以个人并不建议保持开启。 总的来说，如果你对于降噪有着较大的需求，那么加钱依然是你唯一的选择；但如果你看重轻便与运动的特性，并且希望体验一把降噪效果，那么JBL T280NC还是值得一试的。当然，最关键的还是少戴耳机，好比降噪耳机的出现一部分原因是为了让你能够在嘈杂的环境下用更低的音量听歌，而少戴耳机永远是对耳朵最好的呵护。 ▎总结：可降噪，亦轻盈行文至此，不知不觉也写下四千多字。对于JBL T280NC的优缺点，已在众测开头给出，而是否推荐这一款产品呢？还是那句老话——是否符合需求，最重要。 T280NC最大的优势就在于轻，轻带来了极佳的佩戴感受，而虽然轻却也有着12h的最长续航，足以满足一天的使用。（码呆小贴士：单次使用耳机最好不要超过2h，保护耳朵最重要！） 此外，IPX4防水点亮了运动技能树、良好的通话反馈、纯正的低频音效、能用的AAC主动降噪……这些都是JBL T280NC的加分项。因此，如果觉得适合，不妨可以一试。 以上，谢谢观看！我是码呆茶，我们下次再见~","permalink":"https://mondaycha.github.io/2020/02/05/205-3/","photos":["https://zhongces3.sina.com.cn/products/202002/05cf73d8bde2396024e0278984e94867.jpeg"]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"打工？这辈子都不可能哒！（误）","date":"2020/02/05","text":"首先关于今天早上的文……Flag已经倒塌了，在投入了196之后一无所获之后，傍晚再次投入了68元……这次出了大库呜呜呜…… 所以，对Flag进行符合我当前人情的改造行动—— 明日开始，除了月卡，再也不买游戏的其他礼包 哈哈哈哈哈哈哈，接下来进入今天的随意摘录—— 管你是魔王还是勇者，想填饱肚子就得工作！原本即将征服世界的魔王撒旦却遭勇者击败，被迫漂流到异世界“日本”。为了赚取生活费，魔王将三坪大的公寓当成临时魔王城，开始过着打工族的生活。没想到勇者竟追随他的脚步穿越时空而来……一出平民路线的奇幻故事就此展开！ 累了，不多写，晚安~","permalink":"https://mondaycha.github.io/2020/02/05/205-2/","photos":[]},{"tags":[{"name":"沉没成本","slug":"沉没成本","permalink":"https://mondaycha.github.io/tags/%E6%B2%89%E6%B2%A1%E6%88%90%E6%9C%AC/"},{"name":"氪金手游","slug":"氪金手游","permalink":"https://mondaycha.github.io/tags/%E6%B0%AA%E9%87%91%E6%89%8B%E6%B8%B8/"}],"categories":[{"name":"摘录","slug":"摘录","permalink":"https://mondaycha.github.io/categories/%E6%91%98%E5%BD%95/"}],"title":"也谈“沉没成本”","date":"2020/02/05","text":"emmm，关于今天早上发生了什么，我想自己也很清楚不需要自己再提醒了，今天很可能是运气很差的一天。 所以，在此庄严地立下Flag—— 除了月卡，再也不买游戏的其他礼包 最后来谈谈经济学中的沉没成本吧—— 沉没成本，是指以往发生的，但与当前决策无关的费用。从决策的角度看，以往发生的费用只是造成当前状态的某个因素，当前决策所要考虑的是未来可能发生的费用及所带来的收益，而不考虑以往发生的费用。 人们在决定是否去做一件事情的时候，不仅是看这件事对自己有没有好处，而且也看过去是不是已经在这件事情上有过投入。我们把这些已经发生不可收回的支出，如时间、金钱、精力等称为“沉没成本”（Sunk Cost）。在经济学和商业决策制定过程中会用到“沉没成本”的概念，代指已经付出且不可收回的成本。沉没成本常用来和可变成本作比较，可变成本可以被改变，而沉没成本则不能被改变。 我可，真是好笑呢hhhh…… 196…… 本文无封面图，发现腾讯系的图床不大好用，过几天想想法子。今天应该还会更新一篇Git学习手记，再说吧。","permalink":"https://mondaycha.github.io/2020/02/05/205-1/","photos":[]},{"tags":[{"name":"ACG","slug":"ACG","permalink":"https://mondaycha.github.io/tags/ACG/"},{"name":"轻小说","slug":"轻小说","permalink":"https://mondaycha.github.io/tags/%E8%BD%BB%E5%B0%8F%E8%AF%B4/"}],"categories":[{"name":"资源","slug":"资源","permalink":"https://mondaycha.github.io/categories/%E8%B5%84%E6%BA%90/"}],"title":"『ePub资源』有时间谈恋爱不如去抽卡！01","date":"2020/02/03","text":"最近有点沉迷氪金手游，所以自己学习了一点Sigil的皮毛，制作了这个充满讽刺意味的轻小说的ePub文件。 链接：https://pan.baidu.com/s/1zQX7l1PDzjMx3rv4U-c34w提取码：2333 感想的话……不知道我的舞猫能不能满宝啊QAQ 刚刚又歪池子了……","permalink":"https://mondaycha.github.io/2020/02/03/203-1/","photos":[]},{"tags":[{"name":"Kindle","slug":"Kindle","permalink":"https://mondaycha.github.io/tags/Kindle/"}],"categories":[{"name":"测评","slug":"测评","permalink":"https://mondaycha.github.io/categories/%E6%B5%8B%E8%AF%84/"}],"title":"Kindle也能用“微信读书”了？实测告诉你体验如何","date":"2020/02/02","text":"前言哈喽大家好，我是码呆茶！在前段时间微信读书推出支持文石/口袋阅等一众国产电子书阅读器的墨水屏版App之后，近日也终于推出了支持Kindle体验版浏览器的网页版。 下面就为大家带来我的体验。先放结论——卡卡卡卡卡卡卡卡卡卡…… 步骤在 Kindle 上使用“微信读书”的步骤还是很简单的，只需三步—— ① 打开 Kindle 右上方的“体验版浏览器”： ② 输入网址：r.qq.com（weread.qq.com也可以，前者更短更方便） ③ 提示需要用微信扫码： 之后就进入微信读书的个人书架了，开始你的阅读吧~ 操作接下来介绍一下Kindle体验版浏览器上微信读书的操作逻辑：不响应滑动操作，所有切换均通过网页上的按钮进行。 比如在书架，只能通过点击右下角的“上一页”和“下一页”来切换页面。 进入书籍内页之后，则多了“书架”（返回主页）、“目录”、“字体”几个选项。由于上方是体验版浏览器的导航栏，下方是阅读相关按键，阅读时的沉浸式体验并不好。 目录同样只能通过按键翻页，好在贴心地给出了“去底部”、“去顶部”的功能，否则对于页数较多的书就有些束手无策。 字体上，只能调节大小。 翻页操作上，你可以通过页面右下角的“上一页”和“下一页”翻页，也可以像平时的习惯一样点击左右侧区域翻页。 目前微信读书网页版的功能还较少，诸如插入笔记、添加书签等功能都不具备。好在在Kindle上使用微信读书网页版时产生的用户阅读记录和在读时长都会同步。 体验体验就是卡卡卡卡卡卡卡卡卡……码呆使用的设备是Kindle Paperwhite 4，下面就是在Kindle上阅读内置电子书的翻页演示—— 和使用网页版微信读书的翻页速度比较—— 差距非常明显，并且在微信读书进入下一章时，还会跳转新网页，于是一晚上体验下来我只记住了五个字——“正在加载中”…… 当然 Kindle 上的微信读书也不是完全没有优点。众所周知，Kindle 在加载夹带图片的电子书时会强制刷新屏幕，伴随着一阵黑白闪烁，身体也似乎渐渐被掏空……而在微信读书上阅读此类书籍就不会有闪瞎狗眼的体验。 另外加入私密书单的电子书无法在Kindle上阅读。比如码呆将某本网文放到了自己的私密书单里（毕竟你也不希望被好友发现每周都只用微信读书看网络小说吧），而在Kindle上就会提示需要先加入书架后再阅读—— 总结总的来说微信读书的Kindle版体验还是比较糟心的……最关键的翻页卡顿和章节间加载都难以解决，功能也比较少。 当然对于能够静下心来阅读的人来说这些都不算什么，毕竟咱也看不了那么快，章节间的加载还能作为休息，做做笔记回顾下本章内容呢……（手动洗白） 以上，祝大家都开心快乐平平安安度过这个寒假！","permalink":"https://mondaycha.github.io/2020/02/02/202-2/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://mondaycha.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"日记","slug":"日记","permalink":"https://mondaycha.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"title":"第一篇文章！","date":"2020/02/02","text":"第一篇文章！前前后后配置了一天终于搭建好了，接下来也加油吧！","permalink":"https://mondaycha.github.io/2020/02/02/202-1/","photos":[]},{"tags":[],"categories":[],"title":"Hello World","date":"2020/02/01","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","permalink":"https://mondaycha.github.io/2020/02/01/201-1/","photos":[]}]}